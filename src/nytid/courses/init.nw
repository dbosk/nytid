\chapter{Course management, the [[courses]] module}\label{courses}

In this chapter we cover the [[nytid.courses]] module and API for managing 
courses.
We want to add courses to course registers (\cref{registry}).

Each course register is a directory.
We can add a course by creating a subdirectory for the course.
Then we can manage access by managing access to that subdirectory.
Each course subdirectory contains a config file for the course.


\section{Code outline}

Here we provide the module [[nytid.courses]] ([[<<init.py>>]]) that is used to 
manage courses found in the course registers.
<<init.py>>=
"""The nytid course management module"""

import typerconf as config

import pathlib
from nytid.courses import registry
from nytid import storage

<<constants>>
<<functions>>
@

We also add tests.
These are all prepended [[test_]] to the function name.
We will run them using [[pytest]].
<<test courses.py>>=
from nytid.cli.courses import *
<<test imports>>

<<test functions>>
@


\section{Adding a new course}

We will add a function [[new]] to create a new course.
<<functions>>=
def new(<<new args>>):
  """
  Creates a new course. It takes the following arguments:

  <<new doc>>
  """
  <<new body>>
@ We will write the help section (docstring) along with the arguments and how 
they are used by the command.

\subsection{Creating the course}\label{CreatingTheCourse}

To create a course, we need a name for the course.
<<new args>>=
name: str,
<<new doc>>=
- `name` (mandatory), which is the human readable nickname of the course. This 
  is used to refer to the course with other parts of nytid.

@

We will create the course by creating a directory in an available courses 
directory and write a [[config.json]] file there.
However, if it exists, we want to exit with an error.
<<new body>>=
<<determine which course register path [[register_path]] to use>>

with storage.open_root(f"{register_path}/{name}") as root:
  try:
    with root.open("config.json", "r") as course_conf_file:
      pass
  except FileNotFoundError:
    course_conf = config.Config()
  else:
    raise FileExistsError(f"The config for {name} already exists: "
                          f"{register_path}/{name}/config.json")

  <<add settings to [[course_conf]]>>

  with root.open("config.json", "w") as course_conf_file:
    course_conf.write_config(course_conf_file)
@

We would first like to create the course in one of the available course 
registers.
If there is only one directory, we'll create the course there.
If there are more, however, we need the user to decide which one to use.
<<new args>>=
course_register: str = None,
<<new doc>>=
- `course_register` is the name of the course register to use. Required if 
  there are more than one course register in the config. Default is `None`, 
  which selects the only available course register. If more registers, raises 
  exception `ValueError`.

<<determine which course register path [[register_path]] to use>>=
if not course_register:
  registers = registry.list()

  if len(registers) > 1:
    raise ValueError(f"Must specify a course register: {registers.keys()}")
  elif len(registers) < 1:
    raise ValueError(f"There are no course registers in the config.")
  else:
    course_register = registers[0]

register_path = registry.get(course_register)
@


\section{Setting the course settings}

We want to be able to set the course settings at two times:
first, when we create the course; second, when we want to see or modify the 
course settings afterwards.

We will have a similar design as the [[config]] command of the [[typerconf]] 
package\footnote{%
  See URL \url{https://pypi.org/project/typerconf/} or
  the latest PDF from URL \url{https://github.com/dbosk/typerconf/releases}.
}.
When we create the course, we will set all options to some value (possibly 
[[None]]).
Then we can let the [[config]] command read the available options from the 
course config.

Let's add the settings.

\subsection{Contact information}

We want to include the contact information for whoever is responsible for the 
course.

Usually, it's the course responsible who will run the [[courses new]] command.
We will let the user adjust the default values through the main config file, in 
the same fashion as Git.
<<new args>>=
contact: str = None,
<<new doc>>=
- `contact` contains the contact information for the course responsible, it can 
  be any format, but we recommend "Firstname Lastname <email>". The default 
  value is built from values in the main config file:

    - `me.name` contains the name,
    - `me.email` contains the email address.

<<add settings to [[course_conf]]>>=
if not contact:
  try:
    contact = config.get("me.name")
  except KeyError:
    contact = ""

  try:
    email = config.get("me.email")
  except KeyError:
    pass
  else:
    if contact:
      contact += f" <{email}>"
    else:
      contact = email

course_conf.set("contact", contact)
@

\subsection{Course code}

Each course has a course code.
We need one to identity the course from year to year and to identify similar 
courses.
The reason we're interested in this is because then we can recruit TAs from 
similar enough courses.
<<new args>>=
code: str,
<<new doc>>=
- `code`, which is the course code. This is to relate the course to other 
  courses through `related_codes`.

<<new args>>=
related_codes: typing.List[str],
<<new doc>>=
- `related_codes`, a list of related course codes. Courses with one of these 
  course codes can share TAs.

<<add settings to [[course_conf]]>>=
course_conf.set("code", code)
course_conf.set("related_codes", related_codes)
@

\subsection{The schedule}

All courses need a schedule for their teaching.
We add a URL to the ICS file, \eg TimeEdit.
<<new args>>=
ics: str,
<<new doc>>=
- `ics` (optional, default None), a URL to an ICS file with the schedule of the 
  course. E.g. a URL to a TimeEdit export/subscription.

<<add settings to [[course_conf]]>>=
course_conf.set("ics", ics)
@

\subsection{The data directory}

Each course also needs a data directory.
The data directory is a directory that only members can access.
It can contain a more detailed config or TA bookings.
The default path is simply to append [[data]] to the course's config path.
<<new args>>=
data_path: str = None,
<<new doc>>=
- `data_path` is the path to the course's data directory. The default value is 
  `None`, that means append `/data` to the course's config directory.

@

If the user didn't specify a data directory, then [[data_path]] will be 
[[None]].
In this case, we should update it with the default value.
We get the default value from [[root.path]] (see
[[<<new body>>]]).
<<add settings to [[course_conf]]>>=
if not data_path:
  data_path = str(root.path / "data")
course_conf.set("data_path", data_path)
@


\section{Revising the config of a course, the [[courses config]] command}

We'll add a [[courses config]] command to show and change the settings of an 
existing course.
This command should be similar to [[typerconf]]'s config command\footnote{%
  This section is an adapted version of that of [[typerconf]].
}, however, we can't reuse that one since we must specify the course; only once 
we have the course can we fetch which config file to use.

The config command should work as follows.
\begin{minted}{text}
nytid courses config course path --set value
\end{minted}
We need to know which course's config to operate on.
This is the only difference to the config command of [[typerconf]].
However, since we can have multiple course registers, the user must be able 
to specify, in case the same name occurs in more than one.
But if the user doesn't specify, we search through all of them.

If we get a path, but the user didn't use [[--set]] and provide a value, we 
simply print the value at the end of the path.
If we get a value through [[--set]], we'll update the value at the end of the 
path (or create it if it doesn't exist).
This corresponds to how the [[.set]] method of [[Config]] works.
<<functions>>=
<<default values for [[config_cmd]]>>

@cli.command(name="config")
def config_cmd(course: str = name_arg_autocomplete,
               courses_dir = courses_dir_option,
               path: str = path_arg,
               values: typing.List[str] = value_arg):
  """
  Reads values from or writes `values` to the config of `course` at `path`.
  """
  <<set [[course]]'s config file as [[conf]]>>
  if values:
    <<change [[values]] to non-list if one-element list>>
    <<if [[values]] is empty string, replace it with [[None]]>>
    conf.set(path, values)
  else:
    print_config(conf.get(path), path)
@

We will now cover [[name_arg_autocomplete]], [[courses_dir_option]] \etc in
[[<<default values for [[config_cmd]]>>]]
as we cover the relevant parts of the algorithm.

\subsection{Finding the course}

Let's start with the course.
We need the name of the course ([[course_name]]) so that we can look it up in 
the course register ([[courses_dir]]) to get its config file.

We'll reuse the [[courses_dir_option]] from earlier, see 
\cref{CreatingTheCourse}.
We don't want to reuse [[name_arg]], since that one lacks autocompletion.
<<default values for [[config_cmd]]>>=
name_arg_autocomplete = typer.Argument(...,
                            help="Name of the course whose config we want to "
                                 "operate on.",
                            autocompletion=complete_course_name)
@

To complete the course name we simply need to look up all matching courses in 
the course registers.
We want to improve the autocompletion for the user by including from which 
course register as course is.
Hence, we need both the course register name and its path.
<<helper functions>>=
def complete_course_name(ctx: typer.Context, incomplete: str):
  """
  Returns a list of course names matching `incomplete`.
  """
  <<populate [[courses_dirs]] with the course registers to use>>
  for course_dir_name, course_dir_path in courses_dirs:
    <<yield (course name, course dir name) tuples that matches [[incomplete]]>>
@

As mentioned above, if the user doesn't specify a course register, we search 
through all of them.
Remember that we want the name--path tuple for each course register.
<<populate [[courses_dirs]] with the course registers to use>>=
courses_dirs = courses_dirs_pairs(ctx.params.get("courses_dir"))
<<helper functions>>=
def courses_dirs_pairs(courses_dir_name=None):
  """
  Returns a list of (name, path)-tuples (pairs) for course registers to use.

  If `courses_dir_name` is None, we use all existing course registers found 
  in the config. Otherwise, we look up the path of the one specified and return 
  a list containing only that name--path-tuple.
  """
  if courses_dir_name:
    return [(courses_dir_name,
             config.get(f"{REGISTERS}.{courses_dir_name}"))]
  else:
    return list(config.get(REGISTERS).items())
@

In the course register, each course has its own subdirectory.
So we simply need to return the subdirectories of [[course_dir_path]] matching 
[[incomplete]] together with [[course_dir_name]].
<<yield (course name, course dir name) tuples that matches [[incomplete]]>>=
courses = all_courses(courses_dir_path)
matching_courses = filter(lambda x: x.startswith(incomplete), courses)
return map(lambda x: (x, f"from {courses_dir_name}"),
           matching_courses)
<<helper functions>>=
def all_courses(courses_dir_path):
  """
  Returns a list (generator) of all courses found in `courses_dir_path`.
  """
  for file in pathlib.Path(course_dir_path).iterdir():
    if file.is_dir():
      yield file.name
@

Now let's turn back to the main problem.
<<set [[course]]'s config file as [[conf]]>>=
courses_dirs = courses_dirs_pairs(courses_dir)

try:
  conf_path = get_conf_path(course, courses_dirs)
except KeyError as err:
  logging.error(err)
  sys.exit(1)

conf = Config()
conf.read_config(conf_path)
@

We want [[get_conf_path]] to ensure a unique match for [[course]].
This means that we must search through all the course registers and keep 
track of the number of matches.
<<helper functions>>=
def get_conf_path(course, courses_dirs):
  """
  Find the course named `course` among all the courses in `courses_dirs`.
  If `course` is not a unique match, it raises a `KeyError`.
  """
  <<[[get_conf_path]] variables>>

  for course_dir_name, course_dir_path in courses_dirs:
    <<search for matches to [[course]] in [[course_dir_path]]>>

  <<check ending criteria for [[get_conf_path]], return>>
@

In each course register, we go through the courses to check for a match.
If we find the course, we note its [[conf_path]] and also note that we had a 
hit in [[courses_dir_name]].
<<search for matches to [[course]] in [[course_dir_path]]>>=
courses = all_courses(course_dir_path)
matching_courses = list(filter(lambda x: x == course, courses))
if len(matching_courses) > 0:
  conf_path = course_dir_path / course / "config.json"
  hits_from_courses_dirs.append(course_dir_name)
<<[[get_conf_path]] variables>>=
hits_from_courses_dirs = []
conf_path = None
@

Once we're through all the courses, we check if we have a non-[[None]] value in 
[[conf_path]].
If not, we didn't find anything.
Otherwise, we check how many entries we have in [[hits_from_courses_dirs]].
If we have more than one, we raise an exception saying there were too many 
matches.
<<check ending criteria for [[get_conf_path]], return>>=
if not conf_path:
  raise KeyError(f"Couldn't find course {course}.")
elif len(hits_from_courses_dirs) > 1:
  raise KeyError(f"Course `{course}` found in "
                  f"several course registers ({hits_from_course_dirs}).")
@

\subsection{Navigating the course config}

We can autocomplete the path since we can predict the possible values.
<<default values for [[config_cmd]]>>=
path_arg = typer.Argument("",
                          help="Path in config, e.g. 'courses.datintro22'. "
                               "Empty string is root of config. Defaults to "
                               "the empty string.",
                          autocompletion=complete_config_path)
@

The [[complete_config_path]] function returns the possible completions for an 
incomplete path from the command line.
<<helper functions>>=
def complete_config_path(ctx: typer.Context, incomplete: str):
  """
  Returns all valid paths in the config starting with `incomplete`.
  """
  courses_dirs = courses_dirs_pairs(ctx.params.get("course_dir"))
  conf_path = get_conf_path(ctx.params.get("course"), courses_dirs)
  conf = Config()
  conf.read_config(conf_path)

  return filter(lambda x: x.startswith(incomplete),
                conf.paths())
@

\subsection{Setting a value in course config}

We let the user supply a list of values to set on the target path.
<<default values for [[config_cmd]]>>=
value_arg = typer.Option([], "-s", "--set",
                         help="Values to store. "
                              "More than one value makes a list. "
                              "Values are treated as JSON if possible.")
@

If the user supplies only one argument on the command line, we don't want it to 
be interpreted as a one-element list, but rather as a value that is not a list.
Hence, we check and convert if necessary.
<<change [[values]] to non-list if one-element list>>=
if len(values) == 1:
  values = values[0]
@

Additionally, if that one element is an empty string, we replace it with 
[[None]] to trigger a delete.
<<if [[values]] is empty string, replace it with [[None]]>>=
if values == "":
  values = None
@

\subsection{Printing the config}

That [[print_config]] function should print the remaining levels of the config 
tree.
And we want it to print on the format of
[[courses.datintro22.url = https://...]].
This function will do a depth-first traversal through the config to print all 
values.
The idea is that the config path will move from the dictionary representation 
in [[conf]] to the string representation in [[path]].
When at the leaf, [[conf]] will contain the value and [[path]] the entire path.
<<helper functions>>=
def print_config(conf, path=""):
  """
  Prints the config tree contained in `conf` to stdout.
  Optional `path` is prepended.
  """
  try:
    for key in conf.keys():
      <<recurse deeper into the config tree>>
  <<print the leaf of config tree and return>>
@

The recursive step is quite straight-forward, we just call [[print_config]] 
with the subtree ([[conf[key]]]) as an argument.
However, we must check whether to prepend anything ([[path]]).
The deeper we progress, the more we want to prepend.
For instance, at the [[courses.datintro22]] level, [[print_config]] only knows 
[[datintro22]], not the [[courses]] parent.
Hence, we must supply [[courses]] to prepend to [[datintro22]] to get 
[[courses.datintro22]].
<<recurse deeper into the config tree>>=
if path:
  print_config(conf[key], f"{path}.{key}")
else:
  print_config(conf[key], key)
@

Finally, we get the base-case by exception.
When a node ([[conf]]) doesn't have an attribute [[.keys()]], we know we're at 
a leaf, so we print it.
Then the complete path is in [[path]], the value in [[conf]].
<<print the leaf of config tree and return>>=
except AttributeError:
  print(f"{path} = {conf}")
@

\subsection{Testing the [[courses config]] command}

Let's test this command.
We'll set up the testing.
<<test functions>>=
runner = CliRunner()

def test_cli():
  <<run tests on [[cli]]>>
<<test imports>>=
from typer.testing import CliRunner
@

Let's look at the actual tests.
<<run tests on [[cli]]>>=
target_course = "test"
target_path = "contact"
target_value = "Test Tester"

result = runner.invoke(cli, ["new", target_course]),

# set example data
result = runner.invoke(cli, ["config", target_course,
                             target_path, "--set", target_value])
assert result.exit_code == 0

# try access nonexisting
result = runner.invoke(cli, ["config", target_course,
                             f"{target_path}.nonexisting"])
assert result.exit_code == 1

# access existing
result = runner.invoke(cli, ["config", target_course,
                             target_path])
assert target_value in result.stdout

# clear config
result = runner.invoke(cli, ["config", target_course,
                             target_path, "--set", None])
assert result.exit_code == 0

# check that it's cleared
result = runner.invoke(cli, ["config", target_course])
assert target_path not in result.stdout
