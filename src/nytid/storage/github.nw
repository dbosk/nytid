\chapter{GitHub storage backend, the \texttt{storage.github} module}
\label{GitHubStorage}

In this chapter we describe how to use GitHub repositories as storage backends 
with access control, the [[storage.github]] module.

GitHub provides both version control through Git and access control through 
repository collaborators and teams.
This module extends the Git storage module to add access control capabilities.


\section{Design overview}

We want to extend the Git storage module with GitHub-specific access control.
The key additions to the basic Git storage are:
\begin{description}
\item[Collaborator management] Add and remove repository collaborators using 
  the GitHub API.
\item[Permission levels] Grant different permission levels (read, write, admin).
\item[GitHub Enterprise support] Work with both github.com and self-hosted 
  GitHub Enterprise instances.
\end{description}

We contrast this with the Git approach:
Git has no built-in access control.
GitHub provides access control through the web interface and API.


\section{Code outline}

The GitHub storage module inherits from the [[git.StorageRoot]] class.
We override the access control methods to use the GitHub API.
<<github.py>>=
from nytid.storage import git
import os
import re
import requests

<<GitHub helper exceptions>>
<<GitHub helper functions>>

class StorageRoot(git.StorageRoot):
  """
  Manages a storage root in a GitHub repository with access control.
  """

  def __init__(self, url: str, token: str = None):
    """
    Uses GitHub repository at `url` as storage root.
    
    Args:
      url: GitHub repository URL (SSH or HTTPS format)
      token: GitHub personal access token for API access.
             If not provided, uses GITHUB_TOKEN environment variable.
    """
    <<initialize GitHub API settings>>
    super().__init__(url)

  <<GitHub storage methods>>
@

We also add tests to verify GitHub storage functionality.
<<test storagegithub.py>>=
import pathlib
import tempfile
import shutil
import os
import subprocess
import pytest
from unittest.mock import Mock, patch, MagicMock
from nytid.storage.github import *

<<GitHub test fixtures>>
<<GitHub test functions>>
@


\section{GitHub API initialization}

When creating a GitHub [[StorageRoot]], we need to set up API access.
We extract the repository owner and name from the URL and configure the GitHub 
API endpoint.

First, we get the GitHub token from the parameter or environment.
<<initialize GitHub API settings>>=
self.__token = token or os.environ.get("GITHUB_TOKEN")
if not self.__token:
  raise GitHubError(
    "GitHub token required. Provide token parameter or set GITHUB_TOKEN "
    "environment variable."
  )

<<extract repository owner and name from URL>>
<<determine GitHub API endpoint>>
<<configure API headers>>
@

We parse the repository owner and name from various GitHub URL formats.
<<extract repository owner and name from URL>>=
owner, repo_name = extract_github_repo_info(url)
self.__owner = owner
self.__repo = repo_name
@

We need a helper function to extract owner and repository name.
<<GitHub helper functions>>=
def extract_github_repo_info(url: str) -> tuple:
  """
  Extracts GitHub repository owner and name from URL.
  
  Examples:
    'git@github.com:user/repo.git' -> ('user', 'repo')
    'https://github.com/user/repo.git' -> ('user', 'repo')
    'https://github.enterprise.com/user/repo' -> ('user', 'repo')
  
  Returns:
    Tuple of (owner, repo_name)
  """
  # Remove .git suffix if present
  if url.endswith(".git"):
    url = url[:-4]
  
  # Extract owner/repo from different formats
  if ":" in url and "@" in url:
    # SSH format: git@github.com:owner/repo
    parts = url.split(":")[-1]
  else:
    # HTTPS format: https://github.com/owner/repo
    parts = "/".join(url.split("/")[-2:])
  
  # Split owner/repo
  components = parts.split("/")
  if len(components) >= 2:
    return (components[-2], components[-1])
  else:
    raise GitHubError(f"Cannot extract owner/repo from URL: {url}")
@

We determine the GitHub API endpoint based on the URL.
For github.com, we use [[https://api.github.com]].
For GitHub Enterprise, we extract the hostname and use 
[[https://hostname/api/v3]].
<<determine GitHub API endpoint>>=
if "github.com" in url:
  self.__api_base = "https://api.github.com"
else:
  # Extract hostname for GitHub Enterprise
  hostname = extract_github_hostname(url)
  self.__api_base = f"https://{hostname}/api/v3"
@

Helper function to extract hostname from URL.
<<GitHub helper functions>>=
def extract_github_hostname(url: str) -> str:
  """
  Extracts hostname from GitHub URL.
  
  Examples:
    'git@github.enterprise.com:user/repo.git' -> 'github.enterprise.com'
    'https://github.enterprise.com/user/repo' -> 'github.enterprise.com'
  """
  if url.startswith("http"):
    # HTTPS format
    match = re.match(r"https?://([^/]+)", url)
    if match:
      return match.group(1)
  elif "@" in url:
    # SSH format
    match = re.match(r"git@([^:]+):", url)
    if match:
      return match.group(1)
  
  raise GitHubError(f"Cannot extract hostname from URL: {url}")
@

We configure the HTTP headers for GitHub API requests.
<<configure API headers>>=
self.__headers = {
  "Authorization": f"token {self.__token}",
  "Accept": "application/vnd.github.v3+json"
}
@

We define an exception for GitHub API errors.
<<GitHub helper exceptions>>=
class GitHubError(Exception):
  pass
@


\section{Granting access to users}

We implement the [[grant_access]] method to add users as repository 
collaborators.
GitHub supports different permission levels: read, write, and admin.

<<GitHub storage methods>>=
def grant_access(self, user: str, permission: str = "push"):
  """
  Grants access to the GitHub repository for a user.
  
  Args:
    user: GitHub username
    permission: Permission level - 'pull' (read), 'push' (write), or 'admin'
  
  Raises:
    GitHubError: If the API request fails
  """
  <<validate permission level>>
  <<add user as collaborator>>
@

We validate that the permission level is one of the supported values.
<<validate permission level>>=
valid_permissions = ["pull", "push", "admin"]
if permission not in valid_permissions:
  raise GitHubError(
    f"Invalid permission '{permission}'. "
    f"Must be one of: {', '.join(valid_permissions)}"
  )
@

We use the GitHub API to add the user as a collaborator.
<<add user as collaborator>>=
url = (
  f"{self.__api_base}/repos/{self.__owner}/{self.__repo}/"
  f"collaborators/{user}"
)
data = {"permission": permission}

try:
  response = requests.put(url, headers=self.__headers, json=data)
  response.raise_for_status()
except requests.exceptions.RequestException as err:
  raise GitHubError(
    f"Failed to grant access to user '{user}': {err}"
  )
@


\section{Revoking access from users}

We implement the [[revoke_access]] method to remove users as repository 
collaborators.

<<GitHub storage methods>>=
def revoke_access(self, user: str):
  """
  Revokes access to the GitHub repository for a user.
  
  Args:
    user: GitHub username
  
  Raises:
    GitHubError: If the API request fails
  """
  <<remove user as collaborator>>
@

We use the GitHub API to remove the user as a collaborator.
<<remove user as collaborator>>=
url = (
  f"{self.__api_base}/repos/{self.__owner}/{self.__repo}/"
  f"collaborators/{user}"
)

try:
  response = requests.delete(url, headers=self.__headers)
  response.raise_for_status()
except requests.exceptions.RequestException as err:
  raise GitHubError(
    f"Failed to revoke access for user '{user}': {err}"
  )
@


\section{Testing the GitHub storage module}

We test the GitHub storage module using mocks for the GitHub API.
This allows us to test without requiring actual GitHub API access.

<<GitHub test fixtures>>=
@pytest.fixture
def mock_github_token():
  """Mock GitHub token for testing"""
  return "test_github_token_12345"

@pytest.fixture
def github_url():
  """Sample GitHub repository URL"""
  return "https://github.com/testuser/testrepo.git"

@pytest.fixture
def github_enterprise_url():
  """Sample GitHub Enterprise repository URL"""
  return "https://github.enterprise.com/testuser/testrepo.git"
@

We test extracting repository information from URLs.
<<GitHub test functions>>=
def test_extract_github_repo_info():
  """Test extracting owner and repo name from GitHub URLs"""
  owner, repo = extract_github_repo_info("git@github.com:user/repo.git")
  assert owner == "user"
  assert repo == "repo"
  
  owner, repo = extract_github_repo_info("https://github.com/user/repo.git")
  assert owner == "user"
  assert repo == "repo"
  
  owner, repo = extract_github_repo_info("https://github.com/user/repo")
  assert owner == "user"
  assert repo == "repo"
@

We test extracting hostname from various URL formats.
<<GitHub test functions>>=
def test_extract_github_hostname():
  """Test extracting hostname from GitHub URLs"""
  hostname = extract_github_hostname("git@github.enterprise.com:user/repo.git")
  assert hostname == "github.enterprise.com"
  
  hostname = extract_github_hostname("https://github.enterprise.com/user/repo")
  assert hostname == "github.enterprise.com"
  
  hostname = extract_github_hostname("git@github.com:user/repo.git")
  assert hostname == "github.com"
@

We test the initialization and API endpoint detection.
<<GitHub test functions>>=
@patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"})
@patch("nytid.storage.github.git.StorageRoot.__init__")
def test_github_api_endpoint_detection(mock_super_init, github_url):
  """Test GitHub API endpoint is correctly determined"""
  mock_super_init.return_value = None
  
  root = StorageRoot(github_url)
  assert root._StorageRoot__api_base == "https://api.github.com"
  assert root._StorageRoot__owner == "testuser"
  assert root._StorageRoot__repo == "testrepo"

@patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"})
@patch("nytid.storage.github.git.StorageRoot.__init__")
def test_github_enterprise_api_endpoint(mock_super_init, github_enterprise_url):
  """Test GitHub Enterprise API endpoint is correctly determined"""
  mock_super_init.return_value = None
  
  root = StorageRoot(github_enterprise_url)
  assert root._StorageRoot__api_base == "https://github.enterprise.com/api/v3"
@

We test granting access with mocked API calls.
<<GitHub test functions>>=
@patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"})
@patch("nytid.storage.github.git.StorageRoot.__init__")
@patch("nytid.storage.github.requests.put")
def test_grant_access(mock_put, mock_super_init, github_url):
  """Test granting access to a user"""
  mock_super_init.return_value = None
  mock_put.return_value = Mock(status_code=201)
  
  root = StorageRoot(github_url)
  root.grant_access("testuser", "push")
  
  mock_put.assert_called_once()
  call_args = mock_put.call_args
  assert "collaborators/testuser" in call_args[0][0]
  assert call_args[1]["json"]["permission"] == "push"

@patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"})
@patch("nytid.storage.github.git.StorageRoot.__init__")
def test_grant_access_invalid_permission(mock_super_init, github_url):
  """Test that invalid permission raises error"""
  mock_super_init.return_value = None
  
  root = StorageRoot(github_url)
  
  try:
    root.grant_access("testuser", "invalid")
    assert False, "Should have raised GitHubError"
  except GitHubError as err:
    assert "Invalid permission" in str(err)
@

We test revoking access with mocked API calls.
<<GitHub test functions>>=
@patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"})
@patch("nytid.storage.github.git.StorageRoot.__init__")
@patch("nytid.storage.github.requests.delete")
def test_revoke_access(mock_delete, mock_super_init, github_url):
  """Test revoking access from a user"""
  mock_super_init.return_value = None
  mock_delete.return_value = Mock(status_code=204)
  
  root = StorageRoot(github_url)
  root.revoke_access("testuser")
  
  mock_delete.assert_called_once()
  call_args = mock_delete.call_args
  assert "collaborators/testuser" in call_args[0][0]
@

We test that missing GitHub token raises an error.
<<GitHub test functions>>=
@patch.dict(os.environ, {}, clear=True)
@patch("nytid.storage.github.git.StorageRoot.__init__")
def test_missing_github_token(mock_super_init, github_url):
  """Test that missing GitHub token raises error"""
  mock_super_init.return_value = None
  
  try:
    root = StorageRoot(github_url)
    assert False, "Should have raised GitHubError"
  except GitHubError as err:
    assert "token required" in str(err)
@
