\chapter{Working with schedules}

In this chapter we describe the module [[nytid.schedules]] that we provide for 
working with schedules, indirectly TimeEdit.
We want to be able to use the course schedule and the personal schedules 
provided by TimeEdit.

The idea is as follows.
We'll use the [[ics]] package to handle events and schedules (calendars).
This means that we can use the ICS exports from TimeEdit, Google Calendar etc.


\section{Outline}

The module consists only of the file [[schedules.py]].
<<schedules.py>>=
<<imports>>
<<constants>>
<<functions>>
@


\section{Representing events}

We will use the ICS calendar format to represent events.
For this we will use the [[ics]] package.
We will use the [[arrow]] package instead of [[datetime]], as this is suggested 
by the [[ics]] package.
<<imports>>=
import arrow.arrow as arrow
import calendar
import dateutil
import ics.event
import ics.icalendar
@ Using the [[ics]] package allows us to work with calendar related things in a 
standard way, so that we later can just import calendars through [[.ics]] 
files.

When we print such an object, it will print the ICS formatted version.
This is useful for creating [[.ics]] files, but not for pretty-printing the 
schedule to the terminal, for instance.
We introduce the two following functions to handle that.
<<functions>>=
def format_header(event, week=True):
    """
    Formats the event header, a one-line representation (week, date, time, 
    event title)

    If the `week` parameter is `True` (default), the week number and weekday 
    will be included in the header.
    """
    header = ""

    if week:
      header += f"Week {event.begin.isocalendar()[1]} " \
                + calendar.day_name[event.begin.weekday()] + " "

    header += event.begin.to(dateutil.tz.tzlocal()).format('DD/MM HH:mm')

    header += f" {event.name}"

    return header

def format_event(event, week=True):
    """
    Takes event (ics.event.Event) object,
    returns long string representation (header, location, description over 
    several lines)

    The `week` parameter is passed to the `format_header` function, it results 
    in the week number and day being included in the header. Default is `True`.
    """
    header = format_header(event, week)
    location = event.location
    description = "\n".join(filter(lambda x: "http" not in x,
            event.description.splitlines()))

    return f"{header}\n{location}\n{description}".strip()
@

\subsection{Testing [[format_header]]}

The header includes week number, weekday, date/time, and event name when
[[week=True]].
Without week info, only date/time and name remain.
This contrast clarifies the effect of the [[week]] parameter.
<<test functions>>=
def test_format_header_with_week():
  event = make_event()
  header = format_header(event, week=True)
  assert "Week 3" in header
  assert "Monday" in header
  assert event.name in header

def test_format_header_without_week():
  event = make_event()
  header = format_header(event, week=False)
  assert "Week" not in header
  assert "Monday" not in header
  assert event.name in header
  assert "15/01" in header
@

\subsection{Testing [[format_event]]}

The long format includes location and description but filters out lines
containing URLs---these are typically TimeEdit booking links that are
noise in a human-readable display.
<<test functions>>=
def test_format_event_includes_location():
  event = make_event(description="Room info\nhttps://timeedit.net")
  result = format_event(event)
  assert "D1" in result
  assert "Room info" in result
  assert "https://timeedit.net" not in result

def test_format_event_without_week():
  event = make_event()
  result = format_event(event, week=False)
  assert "Week" not in result
@

We also want a shorter version, where we can filter the description.
<<functions>>=
def filter_event_description(event_desc, ignore=[
        "http", "grupp", "group", "ID ", "Daniel Bosk"
    ], separator="; "):
    """
    Takes event description event_desc as string,
    returns filtered string with newlines replaced by semicolons.
    Rows of description containing any term in list ignore, will not appear in 
    the returned string.
    The filtered rows of the description are joined again by the string in 
    separator.
    """
    desc_parts = event_desc.splitlines()
    desc_parts_keep = []

    for part in desc_parts:
        found = False
        for term in ignore:
            if term in part:
                found = True
                break

        if not found:
            desc_parts_keep.append(part)

    return separator.join(desc_parts_keep)

def format_event_short(event, week=False):
    """
    Takes event (ics.event.Event) object,
    returns a short string representation (one line)

    The `week` parameter is passed to the `format_header` function, it results 
    in the week number and day being included in the header. Default is 
    `False`.
    """
    header = format_header(event, week)
    description = filter_event_description(event.description)

    return f"{header} {description}".strip()
@

\subsection{Testing [[filter_event_description]]}

The filter removes lines matching any term in the ignore list.
We test the default ignore list, a custom one, a custom separator,
and the edge case of an empty description.
<<test functions>>=
def test_filter_event_description_default_ignore():
  desc = "Teacher A\nhttps://example.com\ngrupp 3\nNotes"
  result = filter_event_description(desc)
  assert "Notes" in result
  assert "Teacher A" in result
  assert "https" not in result
  assert "grupp" not in result

def test_filter_event_description_custom_ignore():
  desc = "Line A\nLine B\nLine C"
  result = filter_event_description(desc, ignore=["B"])
  assert "Line A" in result
  assert "Line B" not in result
  assert "Line C" in result

def test_filter_event_description_custom_separator():
  desc = "Line A\nLine B"
  result = filter_event_description(desc, ignore=[], separator=" | ")
  assert result == "Line A | Line B"

def test_filter_event_description_empty():
  assert filter_event_description("") == ""

def test_filter_event_description_all_filtered():
  desc = "http://example.com\ngrupp 1"
  result = filter_event_description(desc)
  assert result == ""
@

\subsection{Testing [[format_event_short]]}

The short format is a single line: header plus filtered description.
<<test functions>>=
def test_format_event_short_default():
  event = make_event(description="Notes here")
  result = format_event_short(event)
  assert "Notes here" in result
  assert event.name in result

def test_format_event_short_with_week():
  event = make_event()
  result = format_event_short(event, week=True)
  assert "Week" in result
@

Finally, we want to have a CSV version, that returns an event as a list (that 
is, a row in CSV format).
<<functions>>=
def format_event_csv(event, week=False, location=False):
    """
    Takes event (ics.event.Event) object,
    returns a list of strings, which can be used as a row in a CSV file.

      [0] Week number and day (if week is True)
      [1] Date and time
      [2] Event name
      [3] Location (if location is True)
      [4] Description

    The `week` parameter set to True results in the week number and day being 
    included at index 0. Default is `False`.

    The `location` parameter set to True results in the location being included 
    at index 2. Default is `False`.
    """
    row = []

    if week:
      row.append(f"Week {event.begin.isocalendar()[1]} " \
                  + calendar.day_name[event.begin.weekday()])

    row.append(event.begin.to(dateutil.tz.tzlocal()).format('DD/MM HH:mm'))
    row.append(event.name)

    if location:
      row.append(event.location)

    description = filter_event_description(event.description, separator="; ")
    row.append(description)

    return row
@

\subsection{Testing [[format_event_csv]]}

The CSV format returns a list.
The optional [[week]] and [[location]] flags control which columns
appear, changing the list length.
We test all four combinations.
<<test functions>>=
def test_format_event_csv_default():
  event = make_event(description="Notes")
  row = format_event_csv(event)
  assert len(row) == 3
  assert row[1] == event.name

def test_format_event_csv_with_week():
  event = make_event()
  row = format_event_csv(event, week=True)
  assert len(row) == 4
  assert "Week" in row[0]

def test_format_event_csv_with_location():
  event = make_event()
  row = format_event_csv(event, location=True)
  assert len(row) == 4
  assert "D1" in row

def test_format_event_csv_with_week_and_location():
  event = make_event()
  row = format_event_csv(event, week=True, location=True)
  assert len(row) == 5
@


\section{Handling calendars from URLs}

We want to provide a URL to an ICS-formatted file, for instance, an export from 
TimeEdit.
Here we provide a function that takes a URL to an ICS-formatted file and 
returns a calendar, in the same format as the course schedule above.
This will allow us to easily compare to \eg see which sessions someone can 
attend.
<<functions>>=
def read_calendar(url):
  """
  Input: url is a string containing the URL to the ICS-formatted calendar.
  Output: an [[ics.icalendar.Calendar]] object.
  """
  response = nytid.http_utils.http_session.get(url)
  if response.status_code == requests.codes.ok:
    return ics.icalendar.Calendar(imports=response.text)
  raise Exception(response.text)
<<imports>>=
import requests
import nytid.http_utils
@

\subsection{Testing [[read_calendar]]}

Since [[read_calendar]] makes an HTTP request, we mock
[[nytid.http_utils.http_session.get]] to avoid network access.
We test both success (returns a calendar) and failure (raises exception).
<<test functions>>=
def test_read_calendar_success():
  ics_data = """BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Test//Test//EN
BEGIN:VEVENT
SUMMARY:Test Event
DTSTART:20240115T100000Z
DTEND:20240115T120000Z
END:VEVENT
END:VCALENDAR"""
  mock_response = MagicMock()
  mock_response.status_code = 200
  mock_response.text = ics_data

  with patch("nytid.http_utils.http_session.get",
             return_value=mock_response):
    cal = read_calendar("https://example.com/cal.ics")
    assert len(cal.events) == 1

def test_read_calendar_failure():
  mock_response = MagicMock()
  mock_response.status_code = 404
  mock_response.text = "Not Found"

  with patch("nytid.http_utils.http_session.get",
             return_value=mock_response):
    with pytest.raises(Exception, match="Not Found"):
      read_calendar("https://example.com/notfound.ics")
@


\section{Filtering events}

To filter the list of events, we do the following.
We want to filter events using a whitelist, this is because otherwise we'll end 
up with holidays in our sign-up sheet.
When we check, we want to avoid matching substrings, for instance, we want 
\enquote{Exam} (English) but not \enquote{Examinationsdag} (Swedish).
<<functions>>=
def event_filter(events, whitelisted=TIMEEDIT_EVENTS):
  """
  Takes a list of events (ics.event.Event), returns a filtered list of events 
  (generator). The events to include are the teaching events.

  It covers the following events:
  
    <<whitelisted events>>
  """
  for event in events:
    for event_type in whitelisted:
      if re.match(f"^{event_type}(,|\\s|$)", event.name):
        yield event
        break
<<imports>>=
import re
@

The events that we whitelist are taken from TimeEdits activity types\footnote{%
  URL: 
  \url{https://intra.kth.se/polopoly_fs/1.932668.1685102637!/Aktivitetstyper.pdf}
}:
<<constants>>=
TIMEEDIT_EVENTS = [
  <<whitelisted events>>
]
<<whitelisted events>>=
"Datorlaboration", "Computer lab",
"Examination",
"Exkursion", "Excursion",
"Fältövning", "Field exercise",
"Frågestund", "Question time", "Question Time",
"Föreläsning", "Lecture",
"FX-komplettering", "FX-completion",
"Handledning", "Tutorial",
"Information",
"Kontrollskrivning", "Partial Exam/Quiz",
"Laboration", "Lab",
"Lektion", "Lesson",
"Omtenta", "Re-exam", "Re-Exam",
"Presentation",
"Projektarbete", "Project work", "Project Work",
"Redovisning", "Reporting",
"Räknestuga", "Math work session",
"Seminarium", "Seminar",
"Samverkansinlärning", "Supplemental instruction",
"Supplemental Instruction",
"Studiebesök", "Study visit",
"Tentamen", "Exam",
"Upprop", "Roll-call",
"Webinarium", "Webinar",
"Verksamhetsförlagd utbildning", "Pre-service Placement",
"Workshop",
"Övning", "Exercise"
@

\subsection{Testing [[event_filter]]}

The filter uses regex anchored to the start of the event name, matching
only full words---\enquote{Exam} must match but
\enquote{Examinationsdag} must not.
We verify matching events pass through, non-matching events are dropped,
and substring boundaries are respected.
<<test functions>>=
def test_event_filter_matching():
  events = [make_event(name="Laboration, DD1310"),
            make_event(name="Föreläsning DD1310")]
  result = list(event_filter(events))
  assert len(result) == 2

def test_event_filter_non_matching():
  events = [make_event(name="Holiday")]
  result = list(event_filter(events))
  assert len(result) == 0

def test_event_filter_substring_boundary():
  """Exam should match but Examinationsdag should not."""
  events = [make_event(name="Exam"),
            make_event(name="Examinationsdag")]
  result = list(event_filter(events))
  assert len(result) == 1
  assert result[0].name == "Exam"

def test_event_filter_custom_whitelist():
  events = [make_event(name="CustomEvent"),
            make_event(name="Laboration")]
  result = list(event_filter(events,
                             whitelisted=["CustomEvent"]))
  assert len(result) == 1
  assert result[0].name == "CustomEvent"

def test_event_filter_empty():
  result = list(event_filter([]))
  assert result == []
@


\section{Test setup}

We set up the test file.
The key challenge is creating mock events: [[ics.event.Event]] objects have
[[arrow.Arrow]] timestamps.
We use a fixed date so that week numbers and weekday names are deterministic.
<<test schedules.py>>=
import arrow as arrowlib
import datetime
import ics.event
import pytest
from unittest.mock import patch, MagicMock

from nytid.schedules import *

<<test helper: make event>>
<<test functions>>
@

To avoid duplicating event creation logic across tests, we provide a
factory function.
The date defaults to a Monday (2024-01-15) so that the weekday name is
predictable in formatting tests.
We import [[arrow]] as [[arrowlib]] to avoid conflict with the
module-level [[import arrow.arrow as arrow]] in [[schedules.py]].
<<test helper: make event>>=
def make_event(name="Laboration",
               begin="2024-01-15T10:00:00+01:00",
               end="2024-01-15T12:00:00+01:00",
               location="D1",
               description="grupp 1\ngrupp 2"):
  event = ics.event.Event()
  event.name = name
  event.begin = arrowlib.get(begin)
  event.end = arrowlib.get(end)
  event.location = location
  event.description = description
  return event
@
