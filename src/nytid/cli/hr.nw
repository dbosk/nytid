\chapter{The [[cli.hr]] and the [[hr]] subcommands}%
\label{cli.schedule}

In this chapter we introduce the subommands found under [[nytid hr]],
it's the [[cli.hr]] module.
<<hr.py>>=
import datetime
from enum import Enum
import ics.icalendar
import logging
import typer
from typing_extensions import Annotated

from nytid.cli import courses as coursescli
from nytid import courses as courseutils
from nytid import schedules as schedutils

<<imports>>

cli = typer.Typer(name="hr",
                  help="Managing time for teaching")

<<helper functions>>
<<argument and option definitions>>
<<subcommands>>
@


\section{Default arguments for matching courses}

The first argument we need is to identify a set of courses.
For this we might also have to identify a set of registers.
We'll use the argument and option defined in the [[cli.courses]] module.
We'll default to all courses ([[.*]]) in the register of the [[mine]] command.
<<default arguments for matching courses>>=
course: Annotated[str, coursescli.course_arg_regex] = ".*",
register: Annotated[str, coursescli.register_opt_regex] = coursescli.MINE
@

\section{Generating the schedule}

We want to generate a schedule containing the schedules of all matching 
courses.
<<generate [[schedule]]>>=
<<let [[the_courses]] be a list of (course, register)-pairs>>

schedule = ics.icalendar.Calendar()

for a_course, a_register in the_courses:
  <<add schedule of [[a_course]] to [[schedule]]>>
@

\subsubsection{Find the courses}

We can easily find the courses using the helper functions from the [[coursescli]] 
module.
<<let [[the_courses]] be a list of (course, register)-pairs>>=
registers = coursescli.registers_regex(register)
the_courses = list(coursescli.courses_regex(course, registers))
@

\subsubsection{Merge the schedules}

To create one schedule, we simply merge the events from the different 
schedules.
We simply fetch the course's ICS calendar from the course configuration.
Then we can simply get a calendar object from that URL.
<<add schedule of [[a_course]] to [[schedule]]>>=
try:
  course_conf = courseutils.get_course_config(a_course, a_register)
except KeyError as err:
  logging.error(f"Can't find {a_course} in {a_register}: {err}")
  continue

try:
  course_ics_url = course_conf.get("ics")
except KeyError as err:
  logging.error(f"Can't find schedule URL for {a_course}: {err}")
  continue

course_schedule = schedutils.read_calendar(course_ics_url)

schedule.events |= course_schedule.events
@


\section{Generate sign-up sheet}

We want a command that can generate a sign-up sheet that can be used to let the 
TAs sign up using Google Sheets.
<<subcommands>>=
@cli.command()
def generate_signup_sheet(<<default arguments for matching courses>>,
                          <<output options>>):
  """
  Generates a sign-up sheet to be used with Google Sheets for TAs to sign up.
  """
  <<generate sign-up sheet>>
@

We have that [[<<default arguments for matching courses>>]] is the same as 
above, we get [[course]] and [[register]].

Then we can get the list of courses and their ICS URLs.
We then iterate through them and generate a sign-up sheet for each.
<<generate sign-up sheet>>=
registers = coursescli.registers_regex(register)
courses = {course_reg: nytid.courses.get_course_config(*course_reg).get("ics")
           for course_reg in coursescli.courses_regex(course, registers)}

<<compute [[timestamp]]>>
for (course, register), url in courses.items():
  <<compute [[group_size]] for [[course]]>>

  def needed_TAs(event):
    return utils.needed_TAs(event, group_size=group_size)

  <<set [[outfile]] based on [[timestamp]] for [[course]]>>

  sheets.generate_signup_sheet(outfile, url, needed_TAs)
<<imports>>=
from nytid.signup import sheets
from nytid.signup import utils
@

By default, [[utils.needed_TAs]] uses the 12 as the group size.
This is the optimal group size, but we might now have exactly that.
<<compute [[group_size]] for [[course]]>>=
course_conf = courseutils.get_course_config(course)

num_students = course_conf.get("num_students")
num_groups = course_conf.get("num_groups")

group_size = round(num_students / num_groups)
@

We want to output the signup sheets somewhere.
By default we want to store them in each course's data directory.
We'd like to keep track of the ones generated, so we'll include a timestamp as 
part of the name.
<<output options>>=
outpath: Annotated[pathlib.Path, outpath_opt] = None,
<<argument and option definitions>>=
outpath_opt = typer.Option(help="Path where to write the sign-up sheet "
                                "files. Default is in each course's "
                                "data path.")
<<set [[outfile]] based on [[timestamp]] for [[course]]>>=
if not outpath:
  data_root = courseutils.get_course_data(course, register)
  outfile = data_root.path / f"signup-{timestamp}.csv"
else:
  outfile = outpath / f"signup-{course}-{timestamp}.csv"
@

Now, to compute the timestamp we'll need the current time and then we simply 
turn it into a string.
<<compute [[timestamp]]>>=
now = datetime.datetime.now()
timestamp = now.strftime("%Y%m%d-%H%M")
@

\section{Teaching time totals for a course}

<<time.py>>=
import typerconf

from nytid.signup import utils
from nytid.signup import sheets
from nytid.signup import hr

def to_hours(td):
    return td.total_seconds()/60/60

booked = []

for course, url in SIGNUP.items():
    booked += sheets.read_signup_sheet_from_url(url)

h_per_student = hr.hours_per_student(booked)

print("# dasak")

for event, hours in h_per_student.items():
    print(f"{event}: {to_hours(hours):.2f} h/student")

print(f"Booked: {to_hours(hr.total_hours(booked)):.2f} h "
        f"({to_hours(hr.max_hours(booked)):.2f} h)\n")


print("# Amanuenser")
amanuensis = hr.compute_amanuensis_data(booked,
        add_prep_time=config.add_prep_time)
for user, data in amanuensis.items():
    if not user:
        continue
    print(f"{user}: {data[2]:.2f} h, "
          f"{100*hr.compute_percentage(*data):.1f}%: "
          f"{data[0].format('YYYY-MM-DD')}--{data[1].format('YYYY-MM-DD')}")

print()
print("# Hourly")
for user, hours in hr.hours_per_TA(booked, 
                                   add_prep_time=config.add_prep_time).items():
    if not user or user in amanuensis:
        continue
    print(f"{user}: {to_hours(hours):.2f} h")
@

\section{Show schedule with sign-ups}

<<schedule.py.0>>=
import arrow
from config import COURSES, SIGNUP
import ics.icalendar
from nytid.signup import sheets
import nytid.schedules as sched
import sys

def generate_schedule():
    """Generates schedule, uses sys.args, returns schedule
    as ics.icalendar.Calendar object"""

    schedule = ics.icalendar.Calendar()

    for course, url in SIGNUP.items():
        schedule.events |= set(map(sheets.EventFromCSV,
            sheets.read_signup_sheet_from_url(url)))

    return schedule


def main():
    """Main program"""
    schedule = generate_schedule()

    if len(sys.argv) > 1:
        try:
            time_limit = arrow.get(2022, 8, 29).shift(weeks=+int(sys.argv[1]))
        except ValueError as err:
            print(f"{sys.argv[0]}: {err}: "
                  f"first argument must be the number of weeks to print",
                  file=sys.stderr)
            sys.exit(1)

    first = True
    for event in schedule.timeline:
        if first:
            first = False
            current_week = event.begin.isocalendar()[1]
        elif event.begin.isocalendar()[1] != current_week:
            current_week = event.begin.isocalendar()[1]
            print(end="\n\n")

        try:
            if event.begin > time_limit:
                break
        except NameError:
            pass

        print(sched.format_event_short(event) + "; " +
                ", ".join([attendee.email for attendee in event.attendees]))


if __name__ == "__main__":
    main()
@


\section{Booked TAs}

<<booked.py>>=
import arrow
from config import COURSES, SIGNUP
import ics.icalendar
from nytid.signup import sheets
import nytid.schedules as sched
import sys

def events_booked_TAs(csv_rows):
    """
    Input: a list of CSV data (tuples)

    Output: a list of CSV data, only containing booked TAs, excluding the 
    reserves.
    """
    for row in csv_rows:
        booked, _ = sheets.get_booked_TAs_from_csv(row)
        yield row[:len(sheets.SIGNUP_SHEET_HEADER)] + booked


def generate_schedule(csv_rows):
    """
    Generates schedule (ICS format) from a list of CSV rows,
    returns an ics.icalendar.Calendar object.
    """
    schedule = ics.icalendar.Calendar()
    schedule.events |= set(map(sheets.EventFromCSV, csv_rows))

    return schedule


def format_event(event):
    """
    Returns a string representation of the event.
    """
    return f"{sched.format_event_short(event)}; " + \
            ", ".join([attendee.email for attendee in event.attendees])


def main():
    """Main program"""
    booking_data = []
    for _, url in SIGNUP.items():
        booking_data += sheets.read_signup_sheet_from_url(url)

    schedule = generate_schedule(events_booked_TAs(booking_data))
    now = arrow.get(2022, 8, 29)
    if now < arrow.now():
        now = arrow.now()

    if len(sys.argv) > 1:
        try:
            time_limit = now.shift(weeks=+int(sys.argv[1]))
        except ValueError as err:
            print(f"{sys.argv[0]}: {err}: "
                  f"first argument must be the number of weeks to print",
                  file=sys.stderr)
            sys.exit(1)

    first = True
    for event in schedule.timeline:
        try:
            if event.begin < now:
                continue
            elif event.begin > time_limit:
                break
        except NameError:
            pass

        if first:
            first = False
            current_week = event.begin.isocalendar()[1]
        elif event.begin.isocalendar()[1] != current_week:
            current_week = event.begin.isocalendar()[1]
            print(end="\n\n")

        print(format_event(event))


if __name__ == "__main__":
    main()
@

\section{Lacking sign-ups}

<<missing.py>>=
import arrow
from config import COURSES, SIGNUP
import ics.icalendar
from nytid.signup import sheets
import nytid.schedules as sched
import sys

def events_missing_TAs(csv_rows, missing_factor=0.5):
    """
    Input: a list of CSV data (tuples)

    Output: a list of CSV data, only those rows where there are fewer TAs 
    booked than the number of needed TAs.
    """
    needed_TAs_index = sheets.SIGNUP_SHEET_HEADER.index("#Needed TAs")

    for row in csv_rows:
        num_TAs = len(sheets.get_TAs_from_csv(row))
        needed_TAs = int(row[needed_TAs_index])

        if num_TAs < missing_factor * needed_TAs:
            yield row


def generate_schedule(csv_rows):
    """
    Generates schedule (ICS format) from a list of CSV rows,
    returns an ics.icalendar.Calendar object.
    """
    schedule = ics.icalendar.Calendar()
    schedule.events |= set(map(sheets.EventFromCSV, csv_rows))

    return schedule


def format_event(event):
    """
    Returns a string representation of the event.
    """
    return f"{sched.format_event_short(event)}; " + \
            ", ".join([attendee.email for attendee in event.attendees])


def main():
    """Main program"""
    booking_data = []
    for _, url in SIGNUP.items():
        booking_data += sheets.read_signup_sheet_from_url(url)

    schedule = generate_schedule(events_missing_TAs(booking_data))
    now = arrow.get(2022, 8, 29)
    if now < arrow.now():
        now = arrow.now()

    if len(sys.argv) > 1:
        try:
            time_limit = now.shift(weeks=+int(sys.argv[1]))
        except ValueError as err:
            print(f"{sys.argv[0]}: {err}: "
                  f"first argument must be the number of weeks to print",
                  file=sys.stderr)
            sys.exit(1)

    first = True
    for event in schedule.timeline:
        try:
            if event.begin < now:
                continue
            elif event.begin > time_limit:
                break
        except NameError:
            pass

        if first:
            first = False
            current_week = event.begin.isocalendar()[1]
        elif event.begin.isocalendar()[1] != current_week:
            current_week = event.begin.isocalendar()[1]
            print(end="\n\n")

        print(format_event(event))


if __name__ == "__main__":
    main()
@


\section{My ICS}

<<myics.py>>=
import arrow
from config import COURSES, SIGNUP
import functools
import ics.icalendar
from nytid.signup import sheets
import os
import sys

def add_reserve_to_title(ta, event):
    """
    Input: an event in CSV form.
    Ouput: the same CSV data, but with title prepended "RESERVE: " if TA is 
    among the reserves.
    """
    _, reserves = sheets.get_booked_TAs_from_csv(event)
    if ta in reserves:
        event[0] = "RESERVE: " + event[0]

    return event

def generate_schedule():
    """Generates schedule, uses sys.args or USER environment variable, returns 
    schedule as ics.icalendar.Calendar object"""

    schedule_csv = []

    for course, url in SIGNUP.items():
        schedule_csv += sheets.read_signup_sheet_from_url(url)

    if len(sys.argv) < 2:
        user = os.environ["USER"]
    else:
        user = sys.argv[1]

    schedule_csv = sheets.filter_events_by_TA(user, schedule_csv)
    schedule_csv = map(functools.partial(add_reserve_to_title, user), 
            schedule_csv)

    schedule = ics.icalendar.Calendar()
    schedule.events |= set(map(sheets.EventFromCSV, schedule_csv))

    return schedule


def main():
    """Main program"""
    print(generate_schedule())


if __name__ == "__main__":
    main()
@
