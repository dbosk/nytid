\chapter{The \texttt{cli.track} module and% ===> this file was generated automatically by noweave --- better not edit it
         the \texttt{track} subcommands}%
\label{cli.track}

In this chapter we introduce the subcommands found under {\Tt{}nytid\ track\nwendquote},
it's the {\Tt{}cli.track\nwendquote} module for time tracking functionality.

The track command allows teachers to track time spent on various course-related activities
such as meetings, grading, preparation time, lectures, etc. It supports nested labels for
detailed categorization and can export data to various formats including ICS for calendar integration.

\nwfilename{track.nw}\nwbegincode{1}\sublabel{NW3yTv67-2LTSDP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-2LTSDP-1}}}\moddef{track.py~{\nwtagstyle{}\subpageref{NW3yTv67-2LTSDP-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import datetime
import json
import logging
import os
import pathlib
import sys
import subprocess
import typer
from typing_extensions import Annotated
from typing import List, Optional
import time


\LA{}constants~{\nwtagstyle{}\subpageref{NW3yTv67-3UrjvT-1}}\RA{}

cli = typer.Typer(name="track",
                  help="Track time spent on course activities")

\LA{}helper functions~{\nwtagstyle{}\subpageref{NW3yTv67-47YflN-1}}\RA{}
\LA{}data structures~{\nwtagstyle{}\subpageref{NW3yTv67-1iXR5m-1}}\RA{}
\LA{}tracking state management~{\nwtagstyle{}\subpageref{NW3yTv67-3cXHQQ-1}}\RA{}
\LA{}subcommands~{\nwtagstyle{}\subpageref{NW3yTv67-CyCSh-1}}\RA{}
\nwnotused{track.py}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Constants and Configuration}

We need to define where tracking data is stored and some default configurations.

\nwenddocs{}\nwbegincode{3}\sublabel{NW3yTv67-3UrjvT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-3UrjvT-1}}}\moddef{constants~{\nwtagstyle{}\subpageref{NW3yTv67-3UrjvT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-2LTSDP-1}}\nwenddeflinemarkup
DEFAULT_TRACKING_DIR = pathlib.Path.home() / ".nytid" / "tracking"
TRACKING_DATA_FILE = DEFAULT_TRACKING_DIR / "tracking_data.json"
CURRENT_SESSION_FILE = DEFAULT_TRACKING_DIR / "current_session.json"
\nwused{\\{NW3yTv67-2LTSDP-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\section{Data Structures}

We need data structures to represent tracking sessions and time entries.

\nwenddocs{}\nwbegincode{5}\sublabel{NW3yTv67-1iXR5m-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-1iXR5m-1}}}\moddef{data structures~{\nwtagstyle{}\subpageref{NW3yTv67-1iXR5m-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-2LTSDP-1}}\nwenddeflinemarkup
class TrackingEntry:
    """Represents a single time tracking entry"""
    
    def __init__(self, start_time: datetime.datetime, end_time: datetime.datetime, 
                 labels: List[str], description: str = ""):
        self.start_time = start_time
        self.end_time = end_time
        self.labels = labels
        self.description = description
        
    def duration(self) -> datetime.timedelta:
        """Get the duration of this tracking entry"""
        return self.end_time - self.start_time
        
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization"""
        return \{
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat(),
            'labels': self.labels,
            'description': self.description
        \}
    
    @classmethod
    def from_dict(cls, data: dict) -> 'TrackingEntry':
        """Create from dictionary (JSON deserialization)"""
        return cls(
            start_time=datetime.datetime.fromisoformat(data['start_time']),
            end_time=datetime.datetime.fromisoformat(data['end_time']),
            labels=data['labels'],
            description=data.get('description', '')
        )

class ActiveSession:
    """Represents an active tracking session"""
    
    def __init__(self):
        self.label_stack: List[tuple] = []  # (label, start_time) pairs
        
    def push_labels(self, labels: List[str], start_time: datetime.datetime):
        """Add new labels to the tracking stack"""
        for label in labels:
            self.label_stack.append((label, start_time))
    
    def pop_labels(self, count: int = 1) -> List[TrackingEntry]:
        """Remove labels from stack and return completed entries"""
        if not self.label_stack:
            return []
            
        end_time = datetime.datetime.now()
        entries = []
        
        for _ in range(min(count, len(self.label_stack))):
            if self.label_stack:
                label, start_time = self.label_stack.pop()
                # Create labels list from current stack + the popped label
                current_labels = [l for l, _ in self.label_stack] + [label]
                entries.append(TrackingEntry(start_time, end_time, current_labels))
                
        return entries
    
    def clear_all(self) -> List[TrackingEntry]:
        """Clear all labels and return completed entries"""
        return self.pop_labels(len(self.label_stack))
    
    def get_current_labels(self) -> List[str]:
        """Get the current active labels"""
        return [label for label, _ in self.label_stack]
    
    def is_active(self) -> bool:
        """Check if there are any active tracking labels"""
        return len(self.label_stack) > 0
    
    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization"""
        return \{
            'label_stack': [(label, start_time.isoformat()) 
                          for label, start_time in self.label_stack]
        \}
    
    @classmethod
    def from_dict(cls, data: dict) -> 'ActiveSession':
        """Create from dictionary (JSON deserialization)"""
        session = cls()
        session.label_stack = [
            (label, datetime.datetime.fromisoformat(start_time))
            for label, start_time in data.get('label_stack', [])
        ]
        return session
\nwused{\\{NW3yTv67-2LTSDP-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\section{Tracking State Management}

We need functions to manage the tracking state, load and save data.

\nwenddocs{}\nwbegincode{7}\sublabel{NW3yTv67-3cXHQQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-3cXHQQ-1}}}\moddef{tracking state management~{\nwtagstyle{}\subpageref{NW3yTv67-3cXHQQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-2LTSDP-1}}\nwenddeflinemarkup
def ensure_tracking_dir():
    """Ensure the tracking directory exists"""
    DEFAULT_TRACKING_DIR.mkdir(parents=True, exist_ok=True)

def load_tracking_data() -> List[TrackingEntry]:
    """Load tracking data from file"""
    if not TRACKING_DATA_FILE.exists():
        return []
    
    try:
        with open(TRACKING_DATA_FILE, 'r') as f:
            data = json.load(f)
            return [TrackingEntry.from_dict(entry) for entry in data]
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading tracking data: \{e\}")
        return []

def save_tracking_data(entries: List[TrackingEntry]):
    """Save tracking data to file"""
    ensure_tracking_dir()
    with open(TRACKING_DATA_FILE, 'w') as f:
        json.dump([entry.to_dict() for entry in entries], f, indent=2)

def load_active_session() -> ActiveSession:
    """Load active session from file"""
    if not CURRENT_SESSION_FILE.exists():
        return ActiveSession()
    
    try:
        with open(CURRENT_SESSION_FILE, 'r') as f:
            data = json.load(f)
            return ActiveSession.from_dict(data)
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading active session: \{e\}")
        return ActiveSession()

def save_active_session(session: ActiveSession):
    """Save active session to file"""
    ensure_tracking_dir()
    with open(CURRENT_SESSION_FILE, 'w') as f:
        json.dump(session.to_dict(), f, indent=2)

def add_completed_entries(new_entries: List[TrackingEntry]):
    """Add completed entries to tracking data"""
    if not new_entries:
        return
        
    existing_entries = load_tracking_data()
    existing_entries.extend(new_entries)
    save_tracking_data(existing_entries)
\nwused{\\{NW3yTv67-2LTSDP-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\section{Helper Functions}

\nwenddocs{}\nwbegincode{9}\sublabel{NW3yTv67-47YflN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-47YflN-1}}}\moddef{helper functions~{\nwtagstyle{}\subpageref{NW3yTv67-47YflN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-2LTSDP-1}}\nwenddeflinemarkup
def format_duration(duration: datetime.timedelta) -> str:
    """Format a duration in a human-readable way"""
    total_seconds = int(duration.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    
    if hours > 0:
        return f"\{hours\}h \{minutes\}m \{seconds\}s"
    elif minutes > 0:
        return f"\{minutes\}m \{seconds\}s"
    else:
        return f"\{seconds\}s"

def get_labels_display(labels: List[str]) -> str:
    """Get a display string for labels"""
    return " > ".join(labels) if labels else "No labels"
\nwused{\\{NW3yTv67-2LTSDP-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\section{Subcommands}

Now we implement the various subcommands for the track functionality.

\nwenddocs{}\nwbegincode{11}\sublabel{NW3yTv67-CyCSh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-CyCSh-1}}}\moddef{subcommands~{\nwtagstyle{}\subpageref{NW3yTv67-CyCSh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-2LTSDP-1}}\nwenddeflinemarkup
\LA{}start command~{\nwtagstyle{}\subpageref{NW3yTv67-e4fgM-1}}\RA{}
\LA{}stop command~{\nwtagstyle{}\subpageref{NW3yTv67-33INgc-1}}\RA{}
\LA{}status command~{\nwtagstyle{}\subpageref{NW3yTv67-8PkYM-1}}\RA{}
\LA{}run command~{\nwtagstyle{}\subpageref{NW3yTv67-aG7Lr-1}}\RA{}
\LA{}add command~{\nwtagstyle{}\subpageref{NW3yTv67-HA2HI-1}}\RA{}
\LA{}stats command~{\nwtagstyle{}\subpageref{NW3yTv67-3LqcTn-1}}\RA{}
\LA{}export command~{\nwtagstyle{}\subpageref{NW3yTv67-4POOf4-1}}\RA{}
\nwused{\\{NW3yTv67-2LTSDP-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsection{Start Command}

The start command begins tracking time with the specified labels.

\nwenddocs{}\nwbegincode{13}\sublabel{NW3yTv67-e4fgM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-e4fgM-1}}}\moddef{start command~{\nwtagstyle{}\subpageref{NW3yTv67-e4fgM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def start(
    labels: List[str] = typer.Argument(..., help="Labels to track (can be nested)"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o", 
                                               help="Offset start time by this many minutes (negative for past)")
):
    """
    Start tracking time with the given labels.
    Labels are nested, so 'DD1310 lecture' creates a hierarchy.
    Running start again adds new labels to the current tracking.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    # Calculate start time with offset
    start_time = datetime.datetime.now()
    if offset_minutes is not None:
        start_time += datetime.timedelta(minutes=offset_minutes)
    
    # Load current session
    session = load_active_session()
    
    # Add new labels to the session
    session.push_labels(labels, start_time)
    
    # Save session
    save_active_session(session)
    
    # Display current status
    current_labels = session.get_current_labels()
    typer.echo(f"Started tracking: \{get_labels_display(current_labels)\}")
    if offset_minutes is not None:
        typer.echo(f"Start time offset by \{offset_minutes\} minutes: \{start_time.strftime('%H:%M:%S')\}")
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsection{Stop Command}

The stop command ends tracking for the most recent labels or all labels.

\nwenddocs{}\nwbegincode{15}\sublabel{NW3yTv67-33INgc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-33INgc-1}}}\moddef{stop command~{\nwtagstyle{}\subpageref{NW3yTv67-33INgc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def stop(
    all_labels: bool = typer.Option(False, "--all", "-a", 
                                  help="Stop tracking for all active labels"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o",
                                               help="Offset stop time by this many minutes (negative for past)")
):
    """
    Stop tracking. By default stops the most recently started labels.
    Use --all to stop all active tracking.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking session", err=True)
        raise typer.Exit(1)
    
    # Calculate end time with offset  
    end_time = datetime.datetime.now()
    if offset_minutes is not None:
        end_time += datetime.timedelta(minutes=offset_minutes)
        # Update the session's label times if we're offsetting
        for i, (label, start_time) in enumerate(session.label_stack):
            session.label_stack[i] = (label, start_time)
    
    # Stop tracking and get completed entries
    if all_labels:
        completed_entries = session.clear_all()
        save_active_session(ActiveSession())  # Clear the session
        typer.echo("Stopped all tracking")
    else:
        completed_entries = session.pop_labels(1)
        save_active_session(session)
        if session.is_active():
            typer.echo(f"Stopped latest label. Still tracking: \{get_labels_display(session.get_current_labels())\}")
        else:
            typer.echo("Stopped tracking")
    
    # Update end times if offset was provided
    if offset_minutes is not None and completed_entries:
        for entry in completed_entries:
            entry.end_time = end_time
    
    # Save completed entries
    add_completed_entries(completed_entries)
    
    # Display what was completed
    for entry in completed_entries:
        typer.echo(f"Completed: \{get_labels_display(entry.labels)\} (\{format_duration(entry.duration())\})")
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{Status Command}

The status command shows what is currently being tracked.

\nwenddocs{}\nwbegincode{17}\sublabel{NW3yTv67-8PkYM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-8PkYM-1}}}\moddef{status command~{\nwtagstyle{}\subpageref{NW3yTv67-8PkYM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def status():
    """
    Show current tracking status.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking")
        return
    
    typer.echo("Currently tracking:")
    current_time = datetime.datetime.now()
    
    for i, (label, start_time) in enumerate(session.label_stack):
        duration = current_time - start_time
        indent = "  " * i
        typer.echo(f"\{indent\}- \{label\} (for \{format_duration(duration)\})")
    
    total_labels = session.get_current_labels()
    typer.echo(f"\\nFull label hierarchy: \{get_labels_display(total_labels)\}")
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

\subsection{Run Command}

The run command tracks time while executing another command.

\nwenddocs{}\nwbegincode{19}\sublabel{NW3yTv67-aG7Lr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-aG7Lr-1}}}\moddef{run command~{\nwtagstyle{}\subpageref{NW3yTv67-aG7Lr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def run(
    command_args: List[str] = typer.Argument(..., help="Command and arguments to run"),
    labels: List[str] = typer.Option([], "--label", "-l", help="Labels for this tracking session")
):
    """
    Run a command and track the time spent.
    The command should be provided as arguments after the labels.
    """
    if not command_args:
        typer.echo("Error: Command is required", err=True)
        raise typer.Exit(1)
    
    if not labels:
        # Use the command as a label if no labels provided
        labels = [command_args[0]]
    
    start_time = datetime.datetime.now()
    
    # Load current session and add labels
    session = load_active_session()
    session.push_labels(labels, start_time)
    save_active_session(session)
    
    typer.echo(f"Running '\{' '.join(command_args)\}' and tracking as: \{get_labels_display(labels)\}")
    
    try:
        # Run the command
        result = subprocess.run(command_args, capture_output=False)
        exit_code = result.returncode
    except KeyboardInterrupt:
        typer.echo("\\nCommand interrupted", err=True)
        exit_code = 130
    except FileNotFoundError:
        typer.echo(f"Command not found: \{command_args[0]\}", err=True)
        exit_code = 127
    
    # Stop tracking and save the completed entry
    end_time = datetime.datetime.now()
    completed_entries = session.pop_labels(len(labels))
    
    # Update end times
    for entry in completed_entries:
        entry.end_time = end_time
    
    # Save state
    save_active_session(session)
    add_completed_entries(completed_entries)
    
    duration = end_time - start_time
    typer.echo(f"Command completed in \{format_duration(duration)\}")
    
    raise typer.Exit(exit_code)
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\subsection{Add Command}

The add command allows adding arbitrary time intervals.

\nwenddocs{}\nwbegincode{21}\sublabel{NW3yTv67-HA2HI-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-HA2HI-1}}}\moddef{add command~{\nwtagstyle{}\subpageref{NW3yTv67-HA2HI-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def add(
    labels: List[str] = typer.Argument(..., help="Labels for the time entry"),
    duration_minutes: int = typer.Option(..., "--duration", "-d", help="Duration in minutes"),
    start_offset_minutes: int = typer.Option(0, "--start-offset", help="Start time offset in minutes from now (negative for past)"),
    description: str = typer.Option("", "--description", help="Description for this time entry")
):
    """
    Add a time entry for work done when not at the computer.
    Useful for recording time spent in meetings, at whiteboards, etc.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    if duration_minutes <= 0:
        typer.echo("Error: Duration must be positive", err=True)
        raise typer.Exit(1)
    
    # Calculate times
    now = datetime.datetime.now()
    start_time = now + datetime.timedelta(minutes=start_offset_minutes)
    end_time = start_time + datetime.timedelta(minutes=duration_minutes)
    
    # Create and save entry
    entry = TrackingEntry(start_time, end_time, labels, description)
    add_completed_entries([entry])
    
    typer.echo(f"Added entry: \{get_labels_display(labels)\} (\{format_duration(entry.duration())\})")
    if description:
        typer.echo(f"Description: \{description\}")
    typer.echo(f"Time: \{start_time.strftime('%H:%M')\} - \{end_time.strftime('%H:%M')\}")
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar

\subsection{Stats Command}

The stats command provides statistics about time tracking.

\nwenddocs{}\nwbegincode{23}\sublabel{NW3yTv67-3LqcTn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-3LqcTn-1}}}\moddef{stats command~{\nwtagstyle{}\subpageref{NW3yTv67-3LqcTn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def stats(
    days: int = typer.Option(7, "--days", help="Number of days to include in stats"),
    weekly_limit: float = typer.Option(40.0, "--weekly-limit", help="Weekly hour limit for warnings"),
    daily_limit: float = typer.Option(8.0, "--daily-limit", help="Daily hour limit for warnings")
):
    """
    Show statistics about tracked time.
    """
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data available")
        return
    
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    
    # Filter entries within the time range
    recent_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not recent_entries:
        typer.echo(f"No tracking data in the last \{days\} days")
        return
    
    # Calculate totals
    total_time = sum((e.duration() for e in recent_entries), datetime.timedelta())
    total_hours = total_time.total_seconds() / 3600
    
    typer.echo(f"Statistics for the last \{days\} days:")
    typer.echo(f"Total time: \{format_duration(total_time)\} (\{total_hours:.1f\} hours)")
    typer.echo(f"Average per day: \{total_hours/days:.1f\} hours")
    
    # Check against limits
    if total_hours > (weekly_limit * days / 7):
        typer.echo(f"⚠️  Warning: Exceeding weekly limit of \{weekly_limit\} hours per week", err=True)
    
    # Daily breakdown
    typer.echo(f"\\nDaily breakdown:")
    daily_totals = \{\}
    for entry in recent_entries:
        date = entry.start_time.date()
        if date not in daily_totals:
            daily_totals[date] = datetime.timedelta()
        daily_totals[date] += entry.duration()
    
    for date in sorted(daily_totals.keys(), reverse=True):
        duration = daily_totals[date]
        hours = duration.total_seconds() / 3600
        warning = " ⚠️" if hours > daily_limit else ""
        typer.echo(f"  \{date\}: \{format_duration(duration)\} (\{hours:.1f\}h)\{warning\}")
    
    # Label breakdown
    typer.echo(f"\\nTime by top-level labels:")
    label_totals = \{\}
    for entry in recent_entries:
        if entry.labels:
            top_label = entry.labels[0]
            if top_label not in label_totals:
                label_totals[top_label] = datetime.timedelta()
            label_totals[top_label] += entry.duration()
    
    for label, duration in sorted(label_totals.items(), key=lambda x: x[1], reverse=True):
        hours = duration.total_seconds() / 3600
        percentage = (duration.total_seconds() / total_time.total_seconds()) * 100
        typer.echo(f"  \{label\}: \{format_duration(duration)\} (\{hours:.1f\}h, \{percentage:.1f\}%)")
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{Export Command}

The export command allows exporting tracking data to various formats.

\nwenddocs{}\nwbegincode{25}\sublabel{NW3yTv67-4POOf4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-4POOf4-1}}}\moddef{export command~{\nwtagstyle{}\subpageref{NW3yTv67-4POOf4-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3yTv67-CyCSh-1}}\nwenddeflinemarkup
@cli.command()
def export(
    format: str = typer.Option("ics", "--format", "-f", help="Export format (ics, json, csv)"),
    days: int = typer.Option(30, "--days", help="Number of days to export"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output file (stdout if not specified)")
):
    """
    Export tracking data in various formats.
    Supports ICS (calendar), JSON, and CSV formats.
    """
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data to export", err=True)
        return
    
    # Filter by date range
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    filtered_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not filtered_entries:
        typer.echo(f"No tracking data in the last \{days\} days", err=True)
        return
    
    # Generate export data
    if format.lower() == "ics":
        export_data = export_to_ics(filtered_entries)
    elif format.lower() == "json":
        export_data = export_to_json(filtered_entries)
    elif format.lower() == "csv":
        export_data = export_to_csv(filtered_entries)
    else:
        typer.echo(f"Unsupported format: \{format\}", err=True)
        raise typer.Exit(1)
    
    # Output to file or stdout
    if output:
        with open(output, 'w') as f:
            f.write(export_data)
        typer.echo(f"Exported \{len(filtered_entries)\} entries to \{output\}")
    else:
        print(export_data)

def export_to_ics(entries: List[TrackingEntry]) -> str:
    """Export entries to ICS format"""
    try:
        import ics.icalendar
        import ics.event
    except ImportError:
        typer.echo("ICS export requires the 'ics' package", err=True)
        raise typer.Exit(1)
    
    calendar = ics.icalendar.Calendar()
    
    for entry in entries:
        event = ics.event.Event()
        event.name = f"Work: \{get_labels_display(entry.labels)\}"
        event.begin = entry.start_time
        event.end = entry.end_time
        
        if entry.description:
            event.description = entry.description
        
        # Add labels as categories
        if entry.labels:
            event.categories = set(entry.labels)
        
        calendar.events.add(event)
    
    return str(calendar)

def export_to_json(entries: List[TrackingEntry]) -> str:
    """Export entries to JSON format"""
    return json.dumps([entry.to_dict() for entry in entries], indent=2)

def export_to_csv(entries: List[TrackingEntry]) -> str:
    """Export entries to CSV format"""
    import io
    import csv
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow(['Start Time', 'End Time', 'Duration (minutes)', 'Labels', 'Description'])
    
    # Write entries
    for entry in entries:
        duration_minutes = entry.duration().total_seconds() / 60
        labels_str = " > ".join(entry.labels)
        writer.writerow([
            entry.start_time.isoformat(),
            entry.end_time.isoformat(),
            f"\{duration_minutes:.1f\}",
            labels_str,
            entry.description
        ])
    
    return output.getvalue()
\nwused{\\{NW3yTv67-CyCSh-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

\section{Testing}

We need comprehensive tests for the track functionality.

\nwenddocs{}\nwbegincode{27}\sublabel{NW3yTv67-4WsnEw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3yTv67-4WsnEw-1}}}\moddef{test clitrack.py~{\nwtagstyle{}\subpageref{NW3yTv67-4WsnEw-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import datetime
import json
import os
import pathlib
import tempfile
import pytest
from typer.testing import CliRunner
from unittest.mock import patch

import sys
sys.path.insert(0, '../src')

from nytid.cli.track import cli, TrackingEntry, ActiveSession
from nytid.cli.track import DEFAULT_TRACKING_DIR, TRACKING_DATA_FILE, CURRENT_SESSION_FILE

runner = CliRunner()

@pytest.fixture
def temp_tracking_dir():
    """Create a temporary directory for tracking data during tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_dir = pathlib.Path(tmpdir) / "tracking"
        temp_data_file = temp_dir / "tracking_data.json"
        temp_session_file = temp_dir / "current_session.json"
        
        with patch('nytid.cli.track.DEFAULT_TRACKING_DIR', temp_dir), \\
             patch('nytid.cli.track.TRACKING_DATA_FILE', temp_data_file), \\
             patch('nytid.cli.track.CURRENT_SESSION_FILE', temp_session_file):
            yield temp_dir

def test_status_no_tracking(temp_tracking_dir):
    """Test status command when no tracking is active"""
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "No active tracking" in result.stdout

def test_start_tracking(temp_tracking_dir):
    """Test starting time tracking"""
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Started tracking: DD1310 > lecture" in result.stdout

def test_status_with_active_tracking(temp_tracking_dir):
    """Test status command with active tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Check status
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "Currently tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout

def test_stop_tracking(temp_tracking_dir):
    """Test stopping time tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop tracking
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 0
    assert "Still tracking: DD1310" in result.stdout

def test_stop_all_tracking(temp_tracking_dir):
    """Test stopping all tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop all tracking
    result = runner.invoke(cli, ["stop", "--all"])
    assert result.exit_code == 0
    assert "Stopped all tracking" in result.stdout

def test_add_manual_entry(temp_tracking_dir):
    """Test adding a manual time entry"""
    result = runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60",
        "--description", "Test grading"
    ])
    assert result.exit_code == 0
    assert "Added entry: DD1310 > grading" in result.stdout
    assert "1h 0m 0s" in result.stdout

def test_stats_no_data(temp_tracking_dir):
    """Test stats command with no data"""
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "No tracking data available" in result.stdout

def test_stats_with_data(temp_tracking_dir):
    """Test stats command with data"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60"
    ])
    
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "Statistics for the last 7 days:" in result.stdout
    assert "DD1310:" in result.stdout

def test_export_json(temp_tracking_dir):
    """Test JSON export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading", 
        "--duration", "30"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "json"])
    assert result.exit_code == 0
    # Should be valid JSON
    data = json.loads(result.stdout)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["labels"] == ["DD1310", "grading"]

def test_export_csv(temp_tracking_dir):
    """Test CSV export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "lecture",
        "--duration", "45"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "csv"])
    assert result.exit_code == 0
    assert "Start Time,End Time,Duration" in result.stdout
    assert "DD1310 > lecture" in result.stdout

def test_run_command(temp_tracking_dir):
    """Test run command with tracking"""
    result = runner.invoke(cli, [
        "run", "--label", "DD1310", "--label", "admin",
        "echo", "test"
    ])
    assert result.exit_code == 0
    assert "Running 'echo test'" in result.stdout
    assert "Command completed" in result.stdout

def test_tracking_entry_duration():
    """Test TrackingEntry duration calculation"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 30, 0)
    entry = TrackingEntry(start, end, ["test"], "test entry")
    
    duration = entry.duration()
    assert duration.total_seconds() == 5400  # 1.5 hours

def test_tracking_entry_serialization():
    """Test TrackingEntry to/from dict conversion"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 0, 0)
    entry = TrackingEntry(start, end, ["DD1310", "lecture"], "test")
    
    data = entry.to_dict()
    assert data["labels"] == ["DD1310", "lecture"]
    assert data["description"] == "test"
    
    # Test round-trip
    entry2 = TrackingEntry.from_dict(data)
    assert entry2.start_time == entry.start_time
    assert entry2.end_time == entry.end_time
    assert entry2.labels == entry.labels
    assert entry2.description == entry.description

def test_active_session_operations():
    """Test ActiveSession label stack operations"""
    session = ActiveSession()
    start_time = datetime.datetime.now()
    
    # Test pushing labels
    session.push_labels(["DD1310", "lecture"], start_time)
    assert session.get_current_labels() == ["DD1310", "lecture"]
    assert session.is_active()
    
    # Test popping one label
    entries = session.pop_labels(1)
    assert len(entries) == 1
    assert entries[0].labels == ["DD1310", "lecture"]
    assert session.get_current_labels() == ["DD1310"]
    
    # Test clearing all
    entries = session.clear_all()
    assert len(entries) == 1
    assert not session.is_active()

def test_offset_functionality(temp_tracking_dir):
    """Test time offset functionality"""
    result = runner.invoke(cli, [
        "start", "DD1310", "meeting", "--offset", "-10"
    ])
    assert result.exit_code == 0
    assert "Start time offset by -10 minutes" in result.stdout
    
    result = runner.invoke(cli, [
        "stop", "--offset", "-5"
    ])
    assert result.exit_code == 0

def test_error_cases(temp_tracking_dir):
    """Test various error conditions"""
    # Try to stop when nothing is running
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 1
    assert "No active tracking session" in result.stdout
    
    # Try to add with invalid duration
    result = runner.invoke(cli, [
        "add", "DD1310", "--duration", "0"
    ])
    assert result.exit_code == 1
    assert "Duration must be positive" in result.stdout
    
    # Try to start with no labels
    result = runner.invoke(cli, ["start"])
    assert result.exit_code != 0  # Should fail due to missing required argument
\nwnotused{test clitrack.py}\nwendcode{}

\nwixlogsorted{c}{{add command}{NW3yTv67-HA2HI-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-HA2HI-1}}}%
\nwixlogsorted{c}{{constants}{NW3yTv67-3UrjvT-1}{\nwixu{NW3yTv67-2LTSDP-1}\nwixd{NW3yTv67-3UrjvT-1}}}%
\nwixlogsorted{c}{{data structures}{NW3yTv67-1iXR5m-1}{\nwixu{NW3yTv67-2LTSDP-1}\nwixd{NW3yTv67-1iXR5m-1}}}%
\nwixlogsorted{c}{{export command}{NW3yTv67-4POOf4-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-4POOf4-1}}}%
\nwixlogsorted{c}{{helper functions}{NW3yTv67-47YflN-1}{\nwixu{NW3yTv67-2LTSDP-1}\nwixd{NW3yTv67-47YflN-1}}}%
\nwixlogsorted{c}{{run command}{NW3yTv67-aG7Lr-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-aG7Lr-1}}}%
\nwixlogsorted{c}{{start command}{NW3yTv67-e4fgM-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-e4fgM-1}}}%
\nwixlogsorted{c}{{stats command}{NW3yTv67-3LqcTn-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-3LqcTn-1}}}%
\nwixlogsorted{c}{{status command}{NW3yTv67-8PkYM-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-8PkYM-1}}}%
\nwixlogsorted{c}{{stop command}{NW3yTv67-33INgc-1}{\nwixu{NW3yTv67-CyCSh-1}\nwixd{NW3yTv67-33INgc-1}}}%
\nwixlogsorted{c}{{subcommands}{NW3yTv67-CyCSh-1}{\nwixu{NW3yTv67-2LTSDP-1}\nwixd{NW3yTv67-CyCSh-1}}}%
\nwixlogsorted{c}{{test clitrack.py}{NW3yTv67-4WsnEw-1}{\nwixd{NW3yTv67-4WsnEw-1}}}%
\nwixlogsorted{c}{{track.py}{NW3yTv67-2LTSDP-1}{\nwixd{NW3yTv67-2LTSDP-1}}}%
\nwixlogsorted{c}{{tracking state management}{NW3yTv67-3cXHQQ-1}{\nwixu{NW3yTv67-2LTSDP-1}\nwixd{NW3yTv67-3cXHQQ-1}}}%
\nwbegindocs{28}\nwdocspar
\nwenddocs{}
