\chapter{The [[cli.courses]] module and [[courses]] subcommands}\label{courses}

In this chapter we cover the [[nytid.cli.courses]] module and the subcommands 
of the [[courses]] command.
We want to be able to list all courses in the configuration, create new courses 
and add courses to the configuration.

We have the local user configuration keeping track of which courses the user is 
interested in.
This is the default configuration that the [[typerconf]] package manages.

We also have the global configuration keeping track of a course's 
configuration.
This configuration file should be located in shared storage, so that all 
teachers and TAs can read it.
We link to this configuration in the user's local configuration when we add the 
course.

We will simply use the access control of the shared file system to do access 
control to the course configuration files.


\section{Code outline}

We use the structure outlined in \cref{CLIoverview}.
That structure looks like this:
<<courses.py>>=
"""The nytid courses command and subcommands"""

import typerconf as config

import logging
import pathlib
from nytid import storage
import sys
import typer
import typing

cli = typer.Typer(help="Manage courses")

<<helper constants>>
<<helper functions>>

<<subcommands>>

if __name__ == "__main__":
  cli()
@

We also add tests.
These are all prepended [[test_]] to the function name.
We will run them using [[pytest]].
<<test clicourses.py>>=
from nytid.cli.courses import *

<<test imports>>

<<test functions>>
@


\section{Back-end design overview}

In this chapter we will cover the overall storage structure used for data.
The idea is that we have a dictionary containing configurations for several 
courses, we call this a courses directory (or directory of courses).
This way, we can access all existing courses through this directory.
These configurations will point to the course data directories, \ie where the 
actual course data is located.
\Cref{storage-overview} gives an overview of a config using two courses 
directories, one on AFS and one on GitHub.
We note that the locations can be mixed: root on AFS, data on GitHub and the 
other way around.

\begin{figure}
  \includegraphics[width=\columnwidth]{figs/nytid-storage.pdf}
  \caption{\label{storage-overview}%
    An overview of the storage structure.
    The config points to different course root directories (one on AFS, 
    basename [[nytid]]; one on GitHub, basename [[nytid.git]]).
    The root directories in turn point to different course data directories.
    The course data directories are located both on AFS, GitHub and gits-15.
  }
\end{figure}

By this design, we'll let AFS and GitHub do the access control for us.
We will use the [[storage]] module (\cref{storage}) to access the directories 
and manage them.

Since we can have several courses directories, we will refer to them by name in 
other commands.
The idea is similar to that of \enquote{remotes} in Git.


\section{Adding courses directories, the [[directory]] subcommands}

We will now manage the courses directories, where we can find all available 
courses.
We want the subcommands [[add]], [[rm]] and [[ls]].
We will add a new Typer instance for the [[directory]] command and add the 
three subcommands above.
<<subcommands>>=
directory = typer.Typer(name="directory",
                        help="Manage courses directories")

cli.add_typer(directory)

@directory.command(name="ls")
def directory_ls():
  """
  Lists courses directories added to configuration.
  """
  <<list courses directories>>

@directory.command(name="add")
def directory_add(<<directory add args>>):
  """
  Adds a courses directory.

  <<directory add args doc>>
  """
  <<add courses directory>>

@directory.command(name="rm")
def directory_rm(<<directory rm args>>):
  """
  Removes a courses directory.

  <<directory rm args doc>>
  """
  <<remove courses directory>>
@

As mentioned above, we want each courses directory to be named, so that we can 
reference it easily.
This means that we need those two arguments.
<<directory add args>>=
name: str,
courses_dir: str
<<directory add args doc>>=
- `name` is the name to refer to this courses directory
- `courses_dir` is the actual path to the directory
@

Finally, to add the courses directory, we simply enter it into the config.
We replace any existing entry with the same name.
<<add courses directory>>=
<<check that name is valid, raise ValueError otherwise>>
config.set(f"{COURSES_DIRS}.{name}", courses_dir)
<<helper constants>>=
COURSES_DIRS = "courses_dirs"
@

This means that we can list all courses directories by listing the contents of 
the [[courses_dirs]] path in the config.
<<list courses directories>>=
try:
  for name, courses_dir in config.get(COURSES_DIRS).items():
    print(f"{name}\t{courses_dir}")
except KeyError:
  pass
@

Finally, to remove an entry, we simply need the name.
Then we can drop that entry from the config.
<<directory rm args>>=
name
<<directory rm args doc>>=
- `name` is the name of the courses directory entry

@

To remove the entry; we must fetch the dictionary containing all 
name--directory pairs from the config, then we remove this particular 
name--directory pair and, finally, we can set the resulting dictionary to 
replace that entire tree in the config.
<<remove courses directory>>=
<<check that name is valid, raise ValueError otherwise>>
current_dirs = config.get(COURSES_DIRS)
try:
  del current_dirs[name]
except KeyError:
  logging.warning(f"There is no such directory: {name}")
else:
  config.set(COURSES_DIRS, current_dirs)
@

Now, we need to check that the [[name]] is valid, \ie that it doesn't contain 
any periods.
<<check that name is valid, raise ValueError otherwise>>=
if "." in name:
  raise ValueError(f"`{name}` can't contain a period due to config addressing")
@


\section{Adding a new course, the [[courses new]] command}

We will add a [[new]] command to create a new course.
<<subcommands>>=
<<new arguments and options>>

@cli.command()
def new(<<new command args>>):
  """
  Creates a new course. It takes the following arguments:

  <<new command doc>>
  """
  <<new command body>>
@ We will write the help section (docstring) along with the arguments and how 
they are used by the command.

\subsection{Creating the course}\label{CreatingTheCourse}

To create a course, we need a name for the course.
<<new command doc>>=
- `name` (mandatory), which is the human readable nickname of the course. This 
  is used to refer to the course with other parts of nytid.

<<new command args>>=
name: str = name_arg,
<<new arguments and options>>=
name_arg = typer.Argument(...,
                          help="A name to use to refer to the course.")
@

We will create the course by creating a directory in an available courses 
directory and write a [[config.json]] file there.
However, if it exists, we want to exit with an error.
<<new command body>>=
<<determine which course directory to use>>

with storage.open_root(f"{courses_dir}/{name}") as root:
  try:
    with root.open("config.json", "r") as course_conf_file:
      pass
  except FileNotFoundError:
    course_conf = config.Config()
  else:
    logging.error(f"The directory for {name} already exists: "
                  f"{courses_dir}/{name}")
    sys.exit(1)

  <<add settings to [[course_conf]]>>

  with root.open("config.json", "w") as course_conf_file:
    course_conf.write_config(course_conf_file)
@

We would first like to create the course in one of the courses directories 
available.
If there is only one directory, we'll create the course there.
If there are more, however, we need the user to decide which one to use.
<<new command doc>>=
- `courses_dir_name` is the name of the courses directory to use. Required if 
  there are more than one courses directory in the config.

<<new arguments and options>>=
courses_dir_option = typer.Option(None,
                                  help="Name of courses directory to use.",
                                  shell_complete=complete_courses_dir_name)
<<new command args>>=
courses_dir_name: str = courses_dir_option,
<<determine which course directory to use>>=
courses_dirs = config.get(COURSES_DIRS)

if not courses_dir_name:
  if len(courses_dirs) > 1:
    raise ValueError(f"Must specify courses_dir: {courses_dirs.keys()}")
  elif len(courses_dirs) < 1:
    raise ValueError(f"There are no courses directories, "
                     f"see `nytid courses directory --help`.")
  else:
    courses_dir_name = list(courses_dirs.keys())[0]

courses_dir = courses_dirs[courses_dir_name]
@

We also want to have a function for autocompletion in the shell.
We simply filter out the matching names available in the config.
<<helper functions>>=
def complete_courses_dir_name(ctx, param, incomplete: str):
  """
  Returns list of matching courses directory names available.
  """
  return filter(lambda x: x.startswith(incomplete),
                config.get(COURSES_DIRS).keys())
@

\section{Setting the course settings}

We want to be able to set the course settings at two times:
first, when we create the course; second, when we want to see or modify the 
course settings afterwards.

We will have a similar design as the [[config]] command of the [[typerconf]] 
package\footnote{%
  See URL \url{https://pypi.org/project/typerconf/} or
  the latest PDF from URL \url{https://github.com/dbosk/typerconf/releases}.
}.
When we create the course, we will set all options to some value (possibly 
[[None]]).
Then we can let the [[config]] command read the available options from the 
course config.

Let's add the settings.

\subsection{Contact information}

We want to include the contact information for whoever is responsible for the 
course.

Usually, it's the course responsible who will run the [[courses new]] command.
We will let the user adjust the default values through the main config file, in 
the same fashion as Git.
<<new command doc>>=
- `contact` contains the contact information for the course responsible, it can 
  be any format, but we recommend "Firstname Lastname <email>". The default 
  value is built from values in the main config file:

    - `me.name` contains the name,
    - `me.email` contains the email.

<<new command args>>=
contact: str = contact_opt,
<<new arguments and options>>=
contact_opt = typer.Option(None, help="The course responsible's contact info. "
                                      "Default can be set using "
                                      "`nytid config me.name --set xxx` and "
                                      "`nytid config me.email --set yyy`.")
<<add settings to [[course_conf]]>>=
if not contact:
  try:
    contact = config.get("me.name")
  except KeyError:
    contact = ""

  try:
    email = config.get("me.email")
  except KeyError:
    pass
  else:
    if contact:
      contact += f" <{email}>"
    else:
      contact = email

course_conf.set("contact", contact)
@

\subsection{Course code}

Each course has a course code.
We need one to identity the course from year to year and to identify similar 
courses.
The reason we're interested in this is because then we can recruit TAs from 
similar enough courses.
<<new command doc>>=
- `code`, which is the course code. This is to relate the course to other 
  courses through `related_codes`.

<<new command args>>=
code: str = code_opt,
<<new arguments and options>>=
code_opt = typer.Option(None, help="The course code, "
                                   "to relate it to similar courses using "
                                   "`related_codes`.")
<<new command doc>>=
- `related_codes`, a list of related course codes. Courses with one of these 
  course codes can share TAs.

<<new command args>>=
related_codes: typing.List[str] = related_opt,
<<new arguments and options>>=
related_opt = typer.Option([], help="List of related course codes, "
                                    "courses with any of these codes can "
                                    "share TAs.")
<<add settings to [[course_conf]]>>=
course_conf.set("code", code)
course_conf.set("related_codes", related_codes)
@

\subsection{The schedule}

All courses need a schedule for their teaching.
We add a URL to the ICS file, \eg TimeEdit.
<<new command doc>>=
- `ics` (optional, default None), a URL to an ICS file with the schedule of the 
  course. E.g. a URL to a TimeEdit export/subscription.

<<new command args>>=
ics: str = ics_opt,
<<new arguments and options>>=
ics_opt = typer.Option(None, help="A URL to an ICS file containing the "
                                  "schedule. E.g. from TimeEdit.")
<<add settings to [[course_conf]]>>=
course_conf.set("ics", ics)
@

\subsection{The data directory}

Each course also needs a data directory.
The data directory is a directory that only members can access.
It can contain a more detailed config or TA bookings.
The default path is simply to append [[data]] to the course's config path.
<<new command doc>>=
- `data_path` is the path to the course's data directory. The default value is 
  to append `/data` to the course's config directory.

<<new command args>>=
data_path: str = data_path_opt
<<new arguments and options>>=
data_path_opt = typer.Option(None,
                             help="Path to the course's data directory, "
                                  "default is to append `/data` to the "
                                  "course's config directory.")
@

If the user didn't specify a data directory, then [[data_path]] will be 
[[None]].
In this case, we should update it with the default value.
We get the default value from [[root.path]] (see
[[<<new command body>>]]).
<<add settings to [[course_conf]]>>=
if not data_path:
  data_path = str(root.path / "data")
course_conf.set("data_path", data_path)
@


\section{Revising the config of a course, the [[courses config]] command}

We'll add a [[courses config]] command to show and change the settings of an 
existing course.
This command should be similar to [[typerconf]]'s config command\footnote{%
  This section is an adapted version of that of [[typerconf]].
}, however, we can't reuse that one since we must specify the course; only once 
we have the course can we fetch which config file to use.

The config command should work as follows.
\begin{minted}{text}
nytid courses config course path --set value
\end{minted}
We need to know which course's config to operate on.
This is the only difference to the config command of [[typerconf]].
However, since we can have multiple courses directories, the user must be able 
to specify, in case the same name occurs in more than one.
But if the user doesn't specify, we search through all of them.

If we get a path, but the user didn't use [[--set]] and provide a value, we 
simply print the value at the end of the path.
If we get a value through [[--set]], we'll update the value at the end of the 
path (or create it if it doesn't exist).
This corresponds to how the [[.set]] method of [[Config]] works.
<<subcommands>>=
<<default values for [[config_cmd]]>>

@cli.command(name="config")
def config_cmd(course: str = name_arg_autocomplete,
               courses_dir = courses_dir_option,
               path: str = path_arg,
               values: typing.List[str] = value_arg):
  """
  Reads values from or writes `values` to the config of `course` at `path`.
  """
  <<set [[course]]'s config file as [[conf]]>>
  if values:
    <<change [[values]] to non-list if one-element list>>
    <<if [[values]] is empty string, replace it with [[None]]>>
    conf.set(path, values)
  else:
    print_config(conf.get(path), path)
@

We will now cover [[name_arg_autocomplete]], [[courses_dir_option]] \etc in
[[<<default values for [[config_cmd]]>>]]
as we cover the relevant parts of the algorithm.

\subsection{Finding the course}

Let's start with the course.
We need the name of the course ([[course_name]]) so that we can look it up in 
the courses directory ([[courses_dir]]) to get its config file.

We'll reuse the [[courses_dir_option]] from earlier, see 
\cref{CreatingTheCourse}.
We don't want to reuse [[name_arg]], since that one lacks autocompletion.
<<default values for [[config_cmd]]>>=
name_arg_autocomplete = typer.Argument(...,
                            help="Name of the course whose config we want to "
                                 "operate on.",
                            autocompletion=complete_course_name)
@

To complete the course name we simply need to look up all matching courses in 
the courses directories.
We want to improve the autocompletion for the user by including from which 
courses directory as course is.
Hence, we need both the courses directory name and its path.
<<helper functions>>=
def complete_course_name(ctx: typer.Context, incomplete: str):
  """
  Returns a list of course names matching `incomplete`.
  """
  <<populate [[courses_dirs]] with the courses directories to use>>
  for course_dir_name, course_dir_path in courses_dirs:
    <<yield (course name, course dir name) tuples that matches [[incomplete]]>>
@

As mentioned above, if the user doesn't specify a courses directory, we search 
through all of them.
Remember that we want the name--path tuple for each courses directory.
<<populate [[courses_dirs]] with the courses directories to use>>=
courses_dirs = courses_dirs_pairs(ctx.params.get("courses_dir"))
<<helper functions>>=
def courses_dirs_pairs(courses_dir_name=None):
  """
  Returns a list of (name, path)-tuples (pairs) for courses directories to use.

  If `courses_dir_name` is None, we use all existing courses directories found 
  in the config. Otherwise, we look up the path of the one specified and return 
  a list containing only that name--path-tuple.
  """
  if courses_dir_name:
    return [(courses_dir_name,
             config.get(f"{COURSES_DIRS}.{courses_dir_name}"))]
  else:
    return list(config.get(COURSES_DIRS).items())
@

In the courses directory, each course has its own subdirectory.
So we simply need to return the subdirectories of [[course_dir_path]] matching 
[[incomplete]] together with [[course_dir_name]].
<<yield (course name, course dir name) tuples that matches [[incomplete]]>>=
courses = all_courses(courses_dir_path)
matching_courses = filter(lambda x: x.startswith(incomplete), courses)
return map(lambda x: (x, f"from {courses_dir_name}"),
           matching_courses)
<<helper functions>>=
def all_courses(courses_dir_path):
  """
  Returns a list (generator) of all courses found in `courses_dir_path`.
  """
  for file in pathlib.Path(course_dir_path).iterdir():
    if file.is_dir():
      yield file.name
@

Now let's turn back to the main problem.
<<set [[course]]'s config file as [[conf]]>>=
courses_dirs = courses_dirs_pairs(courses_dir)

try:
  conf_path = get_conf_path(course, courses_dirs)
except KeyError as err:
  logging.error(err)
  sys.exit(1)

conf = Config()
conf.read_config(conf_path)
@

We want [[get_conf_path]] to ensure a unique match for [[course]].
This means that we must search through all the courses directories and keep 
track of the number of matches.
<<helper functions>>=
def get_conf_path(course, courses_dirs):
  """
  Find the course named `course` among all the courses in `courses_dirs`.
  If `course` is not a unique match, it raises a `KeyError`.
  """
  <<[[get_conf_path]] variables>>

  for course_dir_name, course_dir_path in courses_dirs:
    <<search for matches to [[course]] in [[course_dir_path]]>>

  <<check ending criteria for [[get_conf_path]], return>>
@

In each courses directory, we go through the courses to check for a match.
If we find the course, we note its [[conf_path]] and also note that we had a 
hit in [[courses_dir_name]].
<<search for matches to [[course]] in [[course_dir_path]]>>=
courses = all_courses(course_dir_path)
matching_courses = list(filter(lambda x: x == course, courses))
if len(matching_courses) > 0:
  conf_path = course_dir_path / course / "config.json"
  hits_from_courses_dirs.append(course_dir_name)
<<[[get_conf_path]] variables>>=
hits_from_courses_dirs = []
conf_path = None
@

Once we're through all the courses, we check if we have a non-[[None]] value in 
[[conf_path]].
If not, we didn't find anything.
Otherwise, we check how many entries we have in [[hits_from_courses_dirs]].
If we have more than one, we raise an exception saying there were too many 
matches.
<<check ending criteria for [[get_conf_path]], return>>=
if not conf_path:
  raise KeyError(f"Couldn't find course {course}.")
elif len(hits_from_courses_dirs) > 1:
  raise KeyError(f"Course `{course}` found in "
                  f"several courses directories ({hits_from_course_dirs}).")
@

\subsection{Navigating the course config}

We can autocomplete the path since we can predict the possible values.
<<default values for [[config_cmd]]>>=
path_arg = typer.Argument("",
                          help="Path in config, e.g. 'courses.datintro22'. "
                               "Empty string is root of config. Defaults to "
                               "the empty string.",
                          autocompletion=complete_config_path)
@

The [[complete_config_path]] function returns the possible completions for an 
incomplete path from the command line.
<<helper functions>>=
def complete_config_path(ctx: typer.Context, incomplete: str):
  """
  Returns all valid paths in the config starting with `incomplete`.
  """
  courses_dirs = courses_dirs_pairs(ctx.params.get("course_dir"))
  conf_path = get_conf_path(ctx.params.get("course"), courses_dirs)
  conf = Config()
  conf.read_config(conf_path)

  return filter(lambda x: x.startswith(incomplete),
                conf.paths())
@

\subsection{Setting a value in course config}

We let the user supply a list of values to set on the target path.
<<default values for [[config_cmd]]>>=
value_arg = typer.Option([], "-s", "--set",
                         help="Values to store. "
                              "More than one value makes a list. "
                              "Values are treated as JSON if possible.")
@

If the user supplies only one argument on the command line, we don't want it to 
be interpreted as a one-element list, but rather as a value that is not a list.
Hence, we check and convert if necessary.
<<change [[values]] to non-list if one-element list>>=
if len(values) == 1:
  values = values[0]
@

Additionally, if that one element is an empty string, we replace it with 
[[None]] to trigger a delete.
<<if [[values]] is empty string, replace it with [[None]]>>=
if values == "":
  values = None
@

\subsection{Printing the config}

That [[print_config]] function should print the remaining levels of the config 
tree.
And we want it to print on the format of
[[courses.datintro22.url = https://...]].
This function will do a depth-first traversal through the config to print all 
values.
The idea is that the config path will move from the dictionary representation 
in [[conf]] to the string representation in [[path]].
When at the leaf, [[conf]] will contain the value and [[path]] the entire path.
<<helper functions>>=
def print_config(conf, path=""):
  """
  Prints the config tree contained in `conf` to stdout.
  Optional `path` is prepended.
  """
  try:
    for key in conf.keys():
      <<recurse deeper into the config tree>>
  <<print the leaf of config tree and return>>
@

The recursive step is quite straight-forward, we just call [[print_config]] 
with the subtree ([[conf[key]]]) as an argument.
However, we must check whether to prepend anything ([[path]]).
The deeper we progress, the more we want to prepend.
For instance, at the [[courses.datintro22]] level, [[print_config]] only knows 
[[datintro22]], not the [[courses]] parent.
Hence, we must supply [[courses]] to prepend to [[datintro22]] to get 
[[courses.datintro22]].
<<recurse deeper into the config tree>>=
if path:
  print_config(conf[key], f"{path}.{key}")
else:
  print_config(conf[key], key)
@

Finally, we get the base-case by exception.
When a node ([[conf]]) doesn't have an attribute [[.keys()]], we know we're at 
a leaf, so we print it.
Then the complete path is in [[path]], the value in [[conf]].
<<print the leaf of config tree and return>>=
except AttributeError:
  print(f"{path} = {conf}")
@

\subsection{Testing the [[courses config]] command}

Let's test this command.
We'll set up the testing.
<<test functions>>=
runner = CliRunner()

def test_cli():
  <<run tests on [[cli]]>>
<<test imports>>=
from typer.testing import CliRunner
@

Let's look at the actual tests.
<<run tests on [[cli]]>>=
target_course = "test"
target_path = "contact"
target_value = "Test Tester"

result = runner.invoke(cli, ["new", target_course]),

# set example data
result = runner.invoke(cli, ["config", target_course,
                             target_path, "--set", target_value])
assert result.exit_code == 0

# try access nonexisting
result = runner.invoke(cli, ["config", target_course,
                             f"{target_path}.nonexisting"])
assert result.exit_code == 1

# access existing
result = runner.invoke(cli, ["config", target_course,
                             target_path])
assert target_value in result.stdout

# clear config
result = runner.invoke(cli, ["config", target_course,
                             target_path, "--set", None])
assert result.exit_code == 0

# check that it's cleared
result = runner.invoke(cli, ["config", target_course])
assert target_path not in result.stdout
