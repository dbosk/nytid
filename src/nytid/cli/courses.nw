\chapter{The [[cli.courses]] module and [[courses]] subcommands}\label{courses}

In this chapter we cover the [[nytid.cli.courses]] module and the subcommands 
of the [[courses]] command.
We want to be able to list all courses in the configuration, create new courses 
and add courses to the configuration.

We have the local user configuration keeping track of which courses the user is 
interested in.
This is the default configuration that the [[typerconf]] package manages.

We also have the global configuration keeping track of a course's 
configuration.
This configuration file should be located in shared storage, so that all 
teachers and TAs can read it.
We link to this configuration in the user's local configuration when we add the 
course.

We will simply use the access control of the shared file system to do access 
control to the course configuration files.


\section{Code outline}

We use the structure outlined in \cref{CLIoverview}.
That structure looks like this:
<<courses.py>>=
"""The nytid courses command and subcommands"""

import typerconf as config

import logging
import typer
import typing

cli = typer.Typer(help="Manage courses")

<<helper constants>>
<<helper functions>>

<<subcommands>>

if __name__ == "__main__":
  cli()
@

We also add tests.
These are all prepended [[test_]] to the function name.
We will run them using [[pytest]].
<<test clicourses.py>>=
from nytid.cli.courses import *

<<test functions>>
@


\section{Back-end design overview}

In this chapter we will cover the overall storage structure used for data.
The idea is that we have a dictionary containing configurations for several 
courses, we call this a courses directory (or directory of courses).
This way, we can access all existing courses through this directory.
These configurations will point to the course data directories, \ie where the 
actual course data is located.
\Cref{storage-overview} gives an overview of a config using two courses 
directories, one on AFS and one on GitHub.
We note that the locations can be mixed: root on AFS, data on GitHub and the 
other way around.

\begin{figure}
  \includegraphics[width=\columnwidth]{figs/nytid-storage.pdf}
  \caption{\label{storage-overview}%
    An overview of the storage structure.
    The config points to different course root directories (one on AFS, 
    basename [[nytid]]; one on GitHub, basename [[nytid.git]]).
    The root directories in turn point to different course data directories.
    The course data directories are located both on AFS, GitHub and gits-15.
  }
\end{figure}

By this design, we'll let AFS and GitHub do the access control for us.
We will use the [[storage]] module (\cref{storage}) to access the directories 
and manage them.

Since we can have several courses directories, we will refer to them by name in 
other commands.
The idea is similar to that of \enquote{remotes} in Git.


\section{Adding courses directories, the [[directory]] subcommands}

We will now manage the courses directories, where we can find all available 
courses.
We want the subcommands [[add]], [[rm]] and [[ls]].
We will add a new Typer instance for the [[directory]] command and add the 
three subcommands above.
<<subcommands>>=
directory = typer.Typer(name="directory",
                        help="Manage courses directories")

cli.add_typer(directory)

@directory.command(name="ls")
def directory_ls():
  """
  Lists courses directories added to configuration.
  """
  <<list courses directories>>

@directory.command(name="add")
def directory_add(<<directory add args>>):
  """
  Adds a courses directory.

  <<directory add args doc>>
  """
  <<add courses directory>>

@directory.command(name="rm")
def directory_rm(<<directory rm args>>):
  """
  Removes a courses directory.

  <<directory rm args doc>>
  """
  <<remove courses directory>>
@

As mentioned above, we want each courses directory to be named, so that we can 
reference it easily.
This means that we need those two arguments.
<<directory add args>>=
name: str,
courses_dir: str
<<directory add args doc>>=
- `name` is the name to refer to this courses directory
- `courses_dir` is the actual path to the directory
@

Finally, to add the courses directory, we simply enter it into the config.
We replace any existing entry with the same name.
<<add courses directory>>=
<<check that name is valid, raise ValueError otherwise>>
config.set(f"{COURSES_DIRS}.{name}", courses_dir)
<<helper constants>>=
COURSES_DIRS = "courses_dirs"
@

This means that we can list all courses directories by listing the contents of 
the [[courses_dirs]] path in the config.
<<list courses directories>>=
try:
  for name, courses_dir in config.get(COURSES_DIRS).items():
    print(f"{name}\t{courses_dir}")
except KeyError:
  pass
@

Finally, to remove an entry, we simply need the name.
Then we can drop that entry from the config.
<<directory rm args>>=
name
<<directory rm args doc>>=
- `name` is the name of the courses directory entry
@

To remove the entry; we must fetch the dictionary containing all 
name--directory pairs from the config, then we remove this particular 
name--directory pair and, finally, we can set the resulting dictionary to 
replace that entire tree in the config.
<<remove courses directory>>=
<<check that name is valid, raise ValueError otherwise>>
current_dirs = config.get(COURSES_DIRS)
try:
  del current_dirs[name]
except KeyError:
  logging.warning(f"There is no such directory: {name}")
else:
  config.set(COURSES_DIRS, current_dirs)
@

Now, we need to check that the [[name]] is valid, \ie that it doesn't contain 
any periods.
<<check that name is valid, raise ValueError otherwise>>=
if "." in name:
  raise ValueError(f"`{name}` can't contain a period due to config addressing")
@


\section{Adding a new course, the \texttt{new} command}

We will add a [[new]] command to create a new course.
<<subcommands>>=
<<new arguments and options>>

@cli.command()
def new(<<new command args>>):
  """
  Creates a new course. It takes the following arguments:

  <<new command doc>>
  """
  <<new command body>>
@ Now we will write the help section (docstring) along with the arguments and 
how they are used by the command.

<<new command doc>>=
- `name` (mandatory), which is the human readable nickname of the course. This 
  is used to refer to the course with other parts of nytid.

@ We add the argument to the argument list of the function.
<<new command args>>=
name: str = name_arg,
@ We add a similar phrasing for the help text of the argument itself, \ie the 
default value that we just set.
<<new arguments and options>>=
name_arg = typer.Argument(...,
                          help="A name to use to refer to the course with "
                               "other nytid commands.")
@

Now let's continue with the rest.
<<new command doc>>=
- `ics` (optional, default None), a URL to an ICS file with the schedule of the 
  course. E.g. a URL to a TimeEdit export/subscription.

<<new command args>>=
ics: str = ics_opt,
<<new arguments and options>>=
ics_opt = typer.Option(None, help="A URL to an ICS file containing the "
                                  "schedule. E.g. from TimeEdit.")

<<new command doc>>=
- `code`, which is the course code. This is to relate the course to other 
  courses through `related_codes`.

<<new command args>>=
code: str = code_opt,
<<new arguments and options>>=
code_opt = typer.Option(None, help="The course code, "
                                   "to relate it to similar courses using "
                                   "`related_codes`.")
<<new command doc>>=
- `related_codes`, a list of related course codes. Courses with one of these 
  course codes can share TAs.

<<new command args>>=
related_codes: typing.List[str] = related_opt,
<<new arguments and options>>=
related_opt = typer.Option([], help="List of related course codes, "
                                    "courses with any of these codes can "
                                    "share TAs.")

<<new command doc>>=
- `conf_path` is the path to the base config dir. The course's name will be 
  appended to this path. Default is read from defaults.courses_conf_dir in 
  config.

<<new command args>>=
conf_path: str = conf_path_opt
@ We want to provide a default path for the courses.
This default we want to store in the config.
However, if it doesn't exist in the config, we will create a default entry for 
it.
The default is a subdirectory [[courses]] in the config directory.
<<new arguments and options>>=
default_conf_dir = "courses.conf_dir"
try:
  config.get(default_conf_dir)
except KeyError:
  config.set(default_conf_dir, f"{config.dirs.user_config_dir}/courses")

conf_path_opt = typer.Option(config.get(default_conf_dir),
                             help=f"Path to the course's config dir.")
@


\subsection{Creating a new course}

<<helper functions>>=
<<new command body>>=
<<test functions>>=
@
