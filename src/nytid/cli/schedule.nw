\chapter{The \texttt{cli.schedule} module and
         the \texttt{schedule} subcommands}%
\label{cli.schedule}

In this chapter we introduce the subcommands found under [[nytid schedule]],
it's the [[cli.schedule]] module.
<<[[schedule.py]]>>=
import datetime
from enum import Enum
import arrow as arrowlib
import dateutil.tz
import ics.event
import logging
import typer
import typerconf as config
from typing import List, Optional
from typing_extensions import Annotated

from nytid.cli import courses as coursescli
from nytid import courses as courseutils
from nytid import schedules as schedutils
from nytid.cli.signupsheets import SIGNUPSHEET_URL_PATH

<<imports>>
<<constants>>

cli = typer.Typer(name="schedule",
                  help="Working with course schedules")

<<helper functions>>
<<argument and option definitions>>
<<subcommands>>
@


\section{Default arguments for matching courses}

The first argument we need is to identify a set of courses.
For this we might also have to identify a set of registers.
We'll use the argument and option defined in the [[cli.courses]] module.
We'll default to all courses ([[.*]]) in the register of the [[mine]] command.
<<argument for matching courses>>=
course: Annotated[str, coursescli.course_arg_regex]
<<option for matching registers, default to mine>>=
register: Annotated[str, coursescli.register_opt_regex] = coursescli.MINE
@

Then we can create a list of course--configuration pairs like this.
<<set list [[courses]] to ((course, register), config)-pairs>>=
registers = coursescli.registers_regex(register)
courses = {}
for course_reg in coursescli.courses_regex(course, registers):
  try:
    courses[course_reg] = courseutils.get_course_config(*course_reg)
  <<handle errors for accessing course data>>
<<handle errors for accessing course data>>=
except KeyError as err:
  logging.warning(err)
except PermissionError as err:
  course, register = course_reg
  logging.warning(f"You don't have access to {course} in {register}: {err}")
@

\section{My ICS, the \texttt{ics} command}

We want a command that outputs an ICS file that can be imported to a calendar, 
such as Google Calendar or Thunderbird.
The idea is to have a command such that you run
\begin{center}
[[nytid schedule ics > ~/public_html/nytid.ics]]
\end{center}
and then can import [[nytid.ics]] to the calendar through the public URL.
That way we can update it easily.
<<subcommands>>=
@cli.command(name="ics")
def ics_cmd(<<argument for matching courses>> = ".*",
            <<option for matching registers, default to mine>>,
            <<option for username to filter for>>):
  """
  Prints ICS data to stdout. Redirect to a .ics file, preferably in 
  ~/public_html, and add it to your calendar.
  """
  <<generate [[schedule]] from sign-up sheets for matching courses>>
  print(schedule.serialize())
<<generate [[schedule]] from sign-up sheets for matching courses>>=
<<set list [[courses]] to ((course, register), config)-pairs>>

schedule = ics.icalendar.Calendar()
<<set refresh rate for [[schedule]]>>
<<set refresh rate for [[schedule]], same as TimeEdit>>

booked = []
for (course, register), config in courses.items():
  try:
    <<fill [[booked]] or [[schedule]] for [[course]] with [[config]]>>
  except Exception as err:
    logging.error(f"Can't read sign-up sheet nor ICS for "
                  f"{course} ({register}): {err}")
    continue

<<add [[booked]] to [[schedule]]>>
<<set meta data for [[schedule]]>>
@

When we read in the bookings for a course, unlike before, we want to use the 
schedule if there is no sign-up sheet available.
If there is no sign-up sheet, we'll get a [[KeyError]] exception when we try to 
get its entry from the course's config.
In that case we use the schedule instead.
<<fill [[booked]] or [[schedule]] for [[course]] with [[config]]>>=
try:
  <<add to [[booked]] from [[course]] in [[register]] using [[config]]>>
except KeyError as err_signupsheet:
  logging.warning(f"Can't read sign-up sheet for {course} ({register}): "
                  f"{err_signupsheet}")
  <<read schedule from [[config]], add to [[schedule]]>>
@

To add the bookings of a course to [[booked]], we simply get the URL of the 
sign-up sheet and read the bookings.
<<add to [[booked]] from [[course]] in [[register]] using [[config]]>>=
url = config.get(SIGNUPSHEET_URL_PATH)
<<convert [[url]] to Google Sheet CSV-export URL if necessary>>
booked += sheets.read_signup_sheet_from_url(url)
<<imports>>=
from nytid.signup import sheets
@

If it's a Google Sheets sharing URL, we want to convert it to the export-CSV 
URL.
<<convert [[url]] to Google Sheet CSV-export URL if necessary>>=
if "docs.google.com" in url:
  url = sheets.google_sheet_to_csv_url(url)
@

We read the ICS URL from the course's config and then read it in and add it to 
[[schedule]].
We also run all the events from the schedule through a filter that removes 
events that are uninteresting.
For instance, we don't want to include events like holidays, exam weeks or 
fairs like KTH Global.
<<read schedule from [[config]], add to [[schedule]]>>=
course_schedule = schedutils.read_calendar(config.get("ics"))
schedule.events.update(schedutils.event_filter(course_schedule.events))
@

We need a username.
We will default to the username of the logged in user.
<<option for username to filter for>>=
user: Annotated[str, username_opt] = default_username
<<argument and option definitions>>=
try:
  default_username = os.environ["USER"]
except KeyError:
  default_username = None

username_opt = typer.Option(help="Username to filter sign-up sheet for, "
                                 "defaults to logged in user's username.")
<<imports>>=
import os
@

We will filter [[booked]] by the sought-after username, if there is one.
We also want to prefix a "RESERVE:" to the event if the person is a reserve and 
not booked to work.
Then we turn it into an ICS calendar object [[schedule]] as desired.
<<add [[booked]] to [[schedule]]>>=
if user:
  booked = sheets.filter_events_by_TA(user, booked)
  booked = map(functools.partial(add_reserve_to_title, user), booked)

schedule.events.update(set(map_drop_exceptions(sheets.EventFromCSV, booked)))
<<imports>>=
import functools
import ics.icalendar
<<helper functions>>=
def map_drop_exceptions(func, iterable):
  """
  Same as map, but ignores exceptions from `func`.
  Logs a warning when an item is dropped.
  """
  for item in iterable:
    try:
      yield func(item)
    except Exception as err:
      logging.warning(f"Dropped {item}: {err}")
@

Now, only that helper function remains.
It takes a TA and an event, checks if the TA is in the list of reserves, if so,
modifies the event to include "RESERVE:" in the title.
<<helper functions>>=
def add_reserve_to_title(ta, event):
  """
  Input: an event in CSV form.
  Ouput: the same CSV data, but with title prepended "RESERVE: " if TA is
  among the reserves.
  """
  _, reserves = sheets.get_booked_TAs_from_csv(event)
  if ta in reserves:
      event[0] = "RESERVE: " + event[0]

  return event
@

\paragraph{Testing [[map_drop_exceptions]]}

This function applies [[func]] to each item but silently drops items
where [[func]] raises an exception, logging a warning.
This is essential for robustness: a single malformed CSV row should not
crash the entire schedule export.
<<test functions>>=
def test_map_drop_exceptions_all_succeed():
  result = list(map_drop_exceptions(int, ["1", "2", "3"]))
  assert result == [1, 2, 3]

def test_map_drop_exceptions_some_fail():
  result = list(map_drop_exceptions(int, ["1", "bad", "3"]))
  assert result == [1, 3]

def test_map_drop_exceptions_all_fail():
  result = list(map_drop_exceptions(int, ["a", "b"]))
  assert result == []

def test_map_drop_exceptions_empty():
  result = list(map_drop_exceptions(int, []))
  assert result == []
@

\paragraph{Testing [[add_reserve_to_title]]}

If a TA is among the reserves (beyond the needed-TAs count), the event
title gets a \enquote{RESERVE:} prefix.
If the TA is booked (within the first N slots), the title stays
unchanged.
<<test functions>>=
def test_add_reserve_to_title_is_reserve():
  row = ["Lab", "2024-01-01 10:00", "2024-01-01 12:00",
         "D1", "1", "alice", "bob"]
  result = add_reserve_to_title("bob", row)
  assert result[0].startswith("RESERVE: ")

def test_add_reserve_to_title_is_booked():
  row = ["Lab", "2024-01-01 10:00", "2024-01-01 12:00",
         "D1", "1", "alice", "bob"]
  result = add_reserve_to_title("alice", row)
  assert not result[0].startswith("RESERVE:")
@

\subsection{Adding refresh interval to ICS output}

ICS supports specifying the refresh interval for a calendar\footnote{%
  See 
  \url{https://icalendar.org/New-Properties-for-iCalendar-RFC-7986/5-7-refresh-interval-property.html}.
  See also
  \url{https://lauren-c-stephen.medium.com/subscribe-to-an-icalendar-feed-in-google-calendar-and-solve-update-issues-79b4e84b3c64}.
}.
However, the ICS library we're using doesn't, but it supports custom properties 
that we can use.
We can set custom properties by using the [[.extra]] attribute.

There are seemingly two ways to do this, and we use both for maximum
client compatibility.
The standards-track approach is the [[REFRESH-INTERVAL]] property.
A complementary method, found by inspecting TimeEdit exports, is to set
method to [[PUBLISH]] and add a property [[X-PUBLISHED-TTL]]; some older
calendar clients only honour this vendor extension.
<<set refresh rate for [[schedule]]>>=
schedule.extra += [ContentLine("REFRESH-INTERVAL",
                               {"VALUE": ["DURATION"]},
                               "PT20M")]
<<set refresh rate for [[schedule]], same as TimeEdit>>=
schedule.method = "PUBLISH"
schedule.extra += [ContentLine("X-PUBLISHED-TTL", {}, "PT20M")]
<<imports>>=
from ics.grammar.parse import ContentLine
@

\subsection{Other metadata for ICS export}

Based on our observations from the TimeEdit exports, we can set other metadata 
in the calendar export.
<<set meta data for [[schedule]]>>=
schedule.name = "Nytid"
if user:
  schedule.name = f"{user}'s nytid"
schedule.extra += [ContentLine("X-WR-CALNAME", {}, schedule.name)]
schedule.description = "Nytid export"
if user:
  schedule.description = f"Nytid export for {user}"
schedule.extra += [ContentLine("X-WR-CALDESC", {}, schedule.description)]
@


\section{Showing the schedule, the \texttt{schedule show} command}

We want a command to just show the schedule in human readable format.
It should be able to include several courses.
We will use regex to match the courses and registers.
<<subcommands>>=
<<external calendar commands>>

@cli.command()
def show(<<argument for matching courses>> = ".*",
         <<option for matching registers, default to mine>>,
         <<option for username to filter for>>,
         <<default arguments for start and end dates>>,
         <<options for external calendar sources>>,
         <<printing control options>>):
  """
  Shows schedule for courses, external calendars and scheduled todos.
  """
  <<double check [[start]] and [[end]] dates>>
  <<generate [[schedule]] from sign-up sheets for matching courses>>
  <<add external calendar events to [[schedule]]>>
  <<add scheduled todo events to [[schedule]]>>
  <<print [[schedule]]>>
@

\subsection{Default arguments for start and end dates}

We'd also like to show only part of the schedule, given a start and end points.
We want to have today as the default start point and a week later as the 
default end point.
<<default arguments for start and end dates>>=
start: Annotated[datetime.datetime, start_date_opt]
  = str(datetime.date.today()),
end: Annotated[datetime.datetime, end_date_opt]
  = str(datetime.date.today() + datetime.timedelta(weeks=1))
<<argument and option definitions>>=
start_date_opt = typer.Option(help="The start date",
                              formats=["%Y-%m-%d"])
end_date_opt = typer.Option(help="The end date",
                            formats=["%Y-%m-%d"])
@

If we change the start date, but not the end date, the end date might be before 
the start date.
A user will likely expect that if they update only the start date, the end date 
will still be a week after the start date.
<<helper functions>>=
def update_end_date(start, end):
  """
  Returns a correct end date.
  """
  if end < start:
    return start + datetime.timedelta(weeks=1)
  return end
<<double check [[start]] and [[end]] dates>>=
end = update_end_date(start, end)
@

\paragraph{Testing [[update_end_date]]}

When a user changes the start date but not the end date, the end date
may be before the start.
In that case, [[update_end_date]] returns start + 1 week.
Otherwise it returns the original end.
<<test functions>>=
def test_update_end_date_end_before_start():
  start = datetime.datetime(2024, 6, 1)
  end = datetime.datetime(2024, 1, 1)
  result = update_end_date(start, end)
  assert result == start + datetime.timedelta(weeks=1)

def test_update_end_date_end_after_start():
  start = datetime.datetime(2024, 1, 1)
  end = datetime.datetime(2024, 6, 1)
  result = update_end_date(start, end)
  assert result == end

def test_update_end_date_equal():
  start = datetime.datetime(2024, 3, 1)
  end = datetime.datetime(2024, 3, 1)
  result = update_end_date(start, end)
  assert result == end
@

\subsection{Managing external calendars}

External calendars can be added once and reused in every
[[schedule show]] run.
These events are both displayed and used as occupied time when scheduling todos.
We persist the list of external sources under the following config key.
<<constants>>=
SCHEDULE_EXTERNAL_ICS_CONFIG = "schedule.external_ics"
@

When removing an external source, we want shell completion to suggest
the currently configured sources so the user can tab-complete instead
of copy-pasting long URLs:

<<helper functions>>=
def complete_external_sources(ctx, args, incomplete):
  """Return configured external sources matching input."""
  try:
    return [
      s for s in get_external_sources()
      if s.startswith(incomplete)
    ]
  except Exception:
    return []
@

<<external calendar commands>>=
externalcli = typer.Typer(name="external",
                          help="Manage external ICS calendars")
cli.add_typer(externalcli)

@externalcli.command(name="add")
def external_add(source: str):
  """
  Adds an external ICS URL or file path.
  """
  sources = get_external_sources()
  if source in sources:
    print(source)
    return

  sources.append(source)
  set_external_sources(sources)
  print(source)

@externalcli.command(name="ls")
def external_ls():
  """
  Lists configured external ICS URL:s/file paths.
  """
  for source in get_external_sources():
    print(source)

@externalcli.command(name="rm")
def external_rm(
  source: str = typer.Argument(
    ..., help="External ICS source to remove",
    autocompletion=complete_external_sources)
):
  """
  Removes an external ICS URL or file path.
  """
  sources = [
    s for s in get_external_sources()
    if s != source
  ]
  set_external_sources(sources)
  print(source)
@

To support scripts and one-off runs, [[schedule show]] can include additional
external sources directly from the command line.
<<options for external calendar sources>>=
external: Annotated[List[str], external_opt] = None
<<argument and option definitions>>=
external_opt = typer.Option("--external", "-x",
                            help="Additional ICS URL or file path")
@

The configured path is a list value in config, but we also accept a single
string value for convenience.
<<helper functions>>=
def as_list(value):
  """
  Coerces a config value to a list of strings.
  """
  if value is None:
    return []
  if isinstance(value, list):
    return [str(v) for v in value if str(v).strip()]

  value = str(value).strip()
  if not value:
    return []

  return [value]

def get_external_sources(cli_sources=None):
  """
  Returns configured external sources merged with CLI-provided ones.
  """
  sources = []
  try:
    sources.extend(as_list(config.get(SCHEDULE_EXTERNAL_ICS_CONFIG)))
  except KeyError:
    pass

  if cli_sources:
    sources.extend(as_list(cli_sources))

  return list(dict.fromkeys(sources))

def set_external_sources(sources):
  """
  Persists external ICS sources.
  """
  config.set(SCHEDULE_EXTERNAL_ICS_CONFIG,
             list(dict.fromkeys(sources)))
@

\paragraph{Testing [[as_list]]}

Configuration values may be missing, scalar, or lists.
We normalize these to a list of non-empty strings.
<<test functions>>=
def test_as_list_none():
  assert as_list(None) == []

def test_as_list_string():
  assert as_list("https://example.com/cal.ics") == [
    "https://example.com/cal.ics"
  ]

def test_as_list_list():
  assert as_list(["a", "", "b"]) == ["a", "b"]
@

\subsection{Scheduling todos around occupied time}

We combine all visible events into one occupied timeline and schedule todos in
the remaining work-hour slots.

\paragraph{Stripping timezone information}

ICS events carry timezone-aware Arrow timestamps, but the free-slot
algorithm uses plain Python [[datetime]] comparisons.
Rather than repeat the [[astimezone().replace(tzinfo=None)]] conversion
at every call site, we factor it into [[local_naive]].
<<helper functions>>=
def local_naive(dt):
  """
  Converts datetime to local naive time for safe comparisons.
  """
  if dt.tzinfo:
    return dt.astimezone().replace(tzinfo=None)
  return dt
@

We also need the reverse: stamping a naive local datetime with the
system timezone so the [[ics]] library does not default to UTC\@.
<<constants>>=
local_tz = dateutil.tz.tzlocal()
@

The function must handle both timezone-aware and naive datetimes, since
ICS events may arrive in either form.
<<test functions>>=
def test_local_naive_with_naive_datetime():
  dt = datetime.datetime(2024, 6, 1, 10, 0)
  assert local_naive(dt) == dt

def test_local_naive_with_aware_datetime():
  import zoneinfo
  tz = zoneinfo.ZoneInfo("UTC")
  dt = datetime.datetime(2024, 6, 1, 10, 0, tzinfo=tz)
  result = local_naive(dt)
  assert result.tzinfo is None
@

When creating ICS events from naive local datetimes, the [[ics]]
library (Arrow-backed) treats them as UTC, so
[[.to(dateutil.tz.tzlocal())]] shifts the displayed time.
This test verifies that wrapping with [[arrowlib.get]] and
[[local_tz]] preserves the intended hour after the round-trip.
<<test functions>>=
def test_todo_event_preserves_local_time():
  """Naive local datetimes must survive ICS round-trip."""
  import arrow as arrowlib
  import dateutil.tz
  naive_dt = datetime.datetime(2026, 3, 2, 12, 0)
  event = ics.event.Event()
  event.begin = arrowlib.get(naive_dt, dateutil.tz.tzlocal())
  displayed = event.begin.to(dateutil.tz.tzlocal())
  assert displayed.hour == 12, (
    f"expected 12:00 local, got {displayed.hour}:00"
  )
@

\paragraph{Extracting busy intervals}

The free-slot algorithm works with plain [[datetime]] pairs rather than
ICS event objects, because it needs to merge and compare intervals
without depending on the calendar library.
[[event_bounds]] converts events to those pairs, silently skipping
events that lack either endpoint---all-day events in some calendar
clients set [[begin]] but leave [[end]] unset.
<<helper functions>>=
def event_bounds(events):
  """
  Converts events to (start, end) datetime pairs.
  """
  bounds = []
  for event in events:
    if not event.begin or not event.end:
      continue
    begin = local_naive(event.begin.datetime)
    end = local_naive(event.end.datetime)
    if end > begin:
      bounds.append((begin, end))

  return bounds
@

<<test functions>>=
def test_event_bounds_skips_missing_times():
  class FakeEvent:
    def __init__(self, begin, end):
      self.begin = begin
      self.end = end

  class FakeArrow:
    def __init__(self, dt):
      self._dt = dt
    @property
    def datetime(self):
      return self._dt

  e1 = FakeEvent(
    FakeArrow(datetime.datetime(2024, 1, 1, 9, 0)),
    FakeArrow(datetime.datetime(2024, 1, 1, 10, 0)),
  )
  e2 = FakeEvent(None, FakeArrow(datetime.datetime(2024, 1, 1, 11, 0)))

  result = event_bounds([e1, e2])
  assert len(result) == 1
  assert result[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 10, 0),
  )
@

\paragraph{Work hours configuration}

We share work-hour settings with [[todo]] so that slot availability is
computed identically in both commands---a user who sets
[[todo.work_start]] will see the same work window in [[schedule show]].
<<constants>>=
TODO_WORK_START_CONFIG = "todo.work_start"
TODO_WORK_END_CONFIG = "todo.work_end"
TODO_WORK_DAYS_CONFIG = "todo.work_days"

DEFAULT_WORK_START = "08:00"
DEFAULT_WORK_END = "17:00"
DEFAULT_WORK_DAYS = "mon,tue,wed,thu,fri"
@

<<helper functions>>=
def work_window():
  """
  Returns (work_start, work_end, work_days).
  """
  try:
    work_start = config.get(TODO_WORK_START_CONFIG)
  except KeyError:
    work_start = DEFAULT_WORK_START

  try:
    work_end = config.get(TODO_WORK_END_CONFIG)
  except KeyError:
    work_end = DEFAULT_WORK_END

  try:
    work_days = config.get(TODO_WORK_DAYS_CONFIG)
  except KeyError:
    work_days = DEFAULT_WORK_DAYS

  if isinstance(work_days, list):
    work_days = ",".join(str(day) for day in work_days)

  work_days = [d.strip().lower() for d in work_days.split(",")]
  return work_start, work_end, work_days
@

\paragraph{Computing free slots}

Given a list of occupied intervals and a date range,
[[compute_free_slots]] returns all contiguous free intervals that fall
within configured work hours.
The algorithm is a day-by-day sweep: for each work day in the range it
clips the work window to the search bounds, subtracts the occupied
intervals (sorted by start), and appends any remaining gaps.
We clip to \emph{now} on the current day so that past time is never
offered as available---a todo scheduled in a slot that has already
passed would be confusing.
<<helper functions>>=
def compute_free_slots(occupied, start, end):
  """
  Returns free slots in [start, end] during work hours.
  """
  <<parse work hours>>
  day_names = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
  now = datetime.datetime.now()
  free_slots = []

  date = start.date()
  while date <= end.date():
    <<skip non-work days>>
    <<build work window for this day>>
    <<clip work window to search range and today>>
    if day_start >= day_end:
      date += datetime.timedelta(days=1)
      continue
    <<subtract occupied intervals>>
    date += datetime.timedelta(days=1)

  return free_slots
@

We start by parsing the configuration-sourced time strings into integer
hours and minutes.
<<parse work hours>>=
work_start, work_end, work_days = work_window()
start_h, start_m = map(int, work_start.split(":"))
end_h, end_m = map(int, work_end.split(":"))
@

Weekends and days not listed in [[work_days]] are silently skipped.
<<skip non-work days>>=
day_name = day_names[date.weekday()]
if day_name not in work_days:
  date += datetime.timedelta(days=1)
  continue
@

We construct nominal work-day boundaries as [[datetime]] objects so
they can be compared directly with event timestamps.
<<build work window for this day>>=
day_start = datetime.datetime.combine(
  date,
  datetime.time(start_h, start_m),
)
day_end = datetime.datetime.combine(
  date,
  datetime.time(end_h, end_m),
)
@

Three constraints shrink the work window: the overall search [[start]]
and [[end]] bounds, and the current time on today's date so we never
schedule in the past.
<<clip work window to search range and today>>=
day_start = max(day_start, start)
day_end = min(day_end, end)

if date == now.date() and now > day_start:
  day_start = now.replace(second=0, microsecond=0)
@

We clip each event to the current day's window, sort by start time,
then walk a cursor forward through the sorted events, appending each
gap between the cursor and the next event start.
<<subtract occupied intervals>>=
day_events = sorted(
  [
    (max(s, day_start), min(e, day_end))
    for s, e in occupied
    if s < day_end and e > day_start
  ],
  key=lambda x: x[0],
)

cursor = day_start
for event_start, event_end in day_events:
  if cursor < event_start:
    free_slots.append((cursor, event_start))
  cursor = max(cursor, event_end)

if cursor < day_end:
  free_slots.append((cursor, day_end))
@

\paragraph{Testing [[compute_free_slots]]}

Free-slot computation is the core scheduling algorithm.
Given a set of occupied intervals and a date range, it returns the
gaps during work hours.
We test with a fixed work window to avoid dependency on configuration.
<<test functions>>=
def test_compute_free_slots_no_events(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "12:00", ["mon"]),
  )
  # 2024-01-01 is a Monday
  start = datetime.datetime(2024, 1, 1, 0, 0)
  end = datetime.datetime(2024, 1, 1, 23, 59)

  # Freeze "now" to the start of the day so it doesn't
  # clip the work window.
  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  slots = compute_free_slots([], start, end)
  assert len(slots) == 1
  assert slots[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 12, 0),
  )

def test_compute_free_slots_with_event(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "12:00", ["mon"]),
  )
  start = datetime.datetime(2024, 1, 1, 0, 0)
  end = datetime.datetime(2024, 1, 1, 23, 59)

  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  occupied = [
    (datetime.datetime(2024, 1, 1, 10, 0),
     datetime.datetime(2024, 1, 1, 11, 0)),
  ]
  slots = compute_free_slots(occupied, start, end)
  assert len(slots) == 2
  assert slots[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 10, 0),
  )
  assert slots[1] == (
    datetime.datetime(2024, 1, 1, 11, 0),
    datetime.datetime(2024, 1, 1, 12, 0),
  )

def test_compute_free_slots_skips_non_work_days(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "17:00", ["mon"]),
  )
  # 2024-01-02 is a Tuesday
  start = datetime.datetime(2024, 1, 2, 0, 0)
  end = datetime.datetime(2024, 1, 2, 23, 59)

  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  slots = compute_free_slots([], start, end)
  assert slots == []
@

\paragraph{Scheduling todos into free slots}

Todo scheduling uses the same priority model as [[todo ls]]: we sort by
effective priority and greedily fill the earliest free slots.
When a todo has no time estimate, we fall back to a default of one hour
so that every task occupies at least a minimal slot.
<<constants>>=
DEFAULT_ESTIMATED_HOURS = 1.0
@

<<helper functions>>=
def schedule_todo_events(user, start, end, occupied):
  """
  Returns VEVENTs for scheduled todos.
  """
  <<load and filter todos>>
  if not todos:
    return []

  free_slots = compute_free_slots(occupied, start, end)
  if not free_slots:
    return []

  <<sort todos by priority>>

  scheduled_events = []
  remaining_slots = list(free_slots)

  for item in todos:
    <<assign todo to slots>>

  return scheduled_events
@

We import [[todo]] here rather than at the top of the file to avoid a
circular import: [[todo]] imports [[schedule]] for scheduling its items,
and [[schedule]] needs [[todo]] only for this helper.
<<load and filter todos>>=
from nytid.cli import todo as todocli

_, todos = todocli.load_todos()
todos = [t for t in todos if t.status != "done"]

if user:
  todos = [t for t in todos if t.who == user]
@

Sorting by effective priority means high-urgency items claim the
earliest available slots.
<<sort todos by priority>>=
now = datetime.datetime.now()
todos.sort(
  key=lambda t: todocli.effective_priority(t, now),
  reverse=True,
)
@

We greedily consume slots until the todo's estimated hours are
satisfied, splitting a slot if the todo needs less than the full slot.

The slot times from [[compute_free_slots]] are naive datetimes in
local time.
When assigned directly to [[event.begin]] and [[event.end]], the
[[ics]] library (which uses Arrow internally) interprets them as
UTC\@.
Later, display functions like [[format_event_csv]] convert to
local time with [[.to(dateutil.tz.tzlocal())]],
which adds the UTC offset \emph{again}---shifting every event
by one hour in CET or two hours in CEST\@.
We avoid this by wrapping the naive datetimes as timezone-aware
Arrow objects in the local timezone, so the subsequent
[[.to(tzlocal())]] conversion is a no-op.
<<assign todo to slots>>=
hours_needed = item.estimated or DEFAULT_ESTIMATED_HOURS
while hours_needed > 0 and remaining_slots:
  slot_start, slot_end = remaining_slots[0]
  slot_hours = (slot_end - slot_start).total_seconds() / 3600
  if slot_hours <= 0:
    remaining_slots.pop(0)
    continue

  if hours_needed >= slot_hours:
    event_end = slot_end
    hours_needed -= slot_hours
    remaining_slots.pop(0)
  else:
    event_end = slot_start + datetime.timedelta(hours=hours_needed)
    remaining_slots[0] = (event_end, slot_end)
    hours_needed = 0

  event = ics.event.Event()
  event.name = f"[TODO] {item.title}"
  event.begin = arrowlib.get(slot_start, local_tz)
  event.end = arrowlib.get(event_end, local_tz)
  event.location = "TODO"
  if item.description:
    event.description = item.description
  elif item.labels:
    event.description = "; ".join(item.labels)
  else:
    event.description = ""
  scheduled_events.append(event)
@

Once we have the course schedule, we merge external calendars and then
schedule todos into the remaining free slots.
The order matters: external calendar events must be merged \emph{before}
we compute free slots for todos, because [[compute_free_slots]] treats
every event already in [[schedule]] as occupied time.
If we scheduled todos first, they would overlap with external commitments
that hadn't been added yet.

External calendars are personal calendars configured by the logged-in
user---they describe \emph{your} commitments, not someone else's.
When [[--user]] is set to a different username (e.g.\ a TA checking a
colleague's sign-up schedule), including your own personal calendar
events would be misleading.
We therefore only merge external calendars when showing your own schedule.
<<add external calendar events to [[schedule]]>>=
if not user or user == default_username:
  external_sources = get_external_sources(external)
  external_calendar = schedutils.read_calendars(external_sources)
  schedule.events.update(external_calendar.events)
@

With all occupied time now in [[schedule]], we extract the busy intervals
and greedily fill the remaining work-hour slots with todos, sorted by
effective priority.
<<add scheduled todo events to [[schedule]]>>=
occupied = event_bounds(schedule.events)
schedule.events.update(schedule_todo_events(user,
                                            start,
                                            end,
                                            occupied))
@

\subsection{Filter events based on start--end time}

Before output, we keep only events overlapping the chosen interval.
<<set [[events]] to filtered timeline>>=
events = []
for event in schedule.timeline:
  if event.end.date() < start.date():
    continue
  if event.begin.date() > end.date():
    continue
  events.append(event)
@

\subsection{Output format}

Like [[todo ls]], we use auto-format by default: rich table in a terminal,
tab-separated CSV when piped.  The [[--output]] option writes CSV to a
file instead of stdout; it also treats the output as non-interactive, so
the header row is included for self-documentation.
<<argument and option definitions>>=
class OutputFormat(str, Enum):
  table = "table"
  rich = "rich"
  csv = "csv"

output_format_opt = typer.Option("--format", "-f",
                                 help="Output format: table, rich or csv",
                                 case_sensitive=False)
@
<<printing control options>>=
output_format: Annotated[OutputFormat, output_format_opt] = "table",

<<determine effective output format>>=
if output_format == OutputFormat.table:
  effective_output_format = (
    "csv" if (output or not sys.stdout.isatty()) else "rich"
  )
elif output_format == OutputFormat.rich:
  effective_output_format = "rich"
else:
  effective_output_format = "csv"
@

\subsection{Printing the events}

We print either a rich table or CSV based on the effective format.
<<print [[schedule]]>>=
<<set [[events]] to filtered timeline>>
<<determine effective output format>>

if effective_output_format == "rich":
  <<print [[events]] as rich table>>
else:
  <<print [[events]] as CSV>>
@

For rich output we display the same core fields as in CSV, but with aligned
columns for interactive reading.
<<print [[events]] as rich table>>=
from rich.console import Console
from rich import box
from rich.table import Table

console = Console()
table = Table(show_header=True,
              header_style="bold",
              box=box.SIMPLE,
              show_edge=False,
              pad_edge=False)
table.add_column("When")
table.add_column("Event")
if location:
  table.add_column("Location")
table.add_column("Description")

for event in events:
  row = schedutils.format_event_csv(event, week=week, location=True)
  if week:
    when = f"{row[0]} {row[1]}"
    title = row[2]
    where = row[3]
    description = row[4]
  else:
    when = row[0]
    title = row[1]
    where = row[2]
    description = row[3]

  if location:
    table.add_row(when, title, where, description)
  else:
    table.add_row(when, title, description)

console.print(table)
@

CSV is always tab-separated by default, so shell tools can process it
directly.  When writing to a file we include a header row so the file is
self-describing.  When piping to another process we omit the header so
that tools such as [[awk]] and [[cut]] can process rows without skipping a
line.  The same rule applies when a TTY is attached: the header is shown
for readability.
<<print [[events]] as CSV>>=
if output:
  dest = open(output, "w", newline="")
else:
  dest = sys.stdout

csvout = csv.writer(dest, delimiter=delimiter)

header = []
if week:
  header.append("week_day")
header += ["start", "event"]
if location:
  header.append("location")
header.append("description")
if output or sys.stdout.isatty():
  csvout.writerow(header)

for event in events:
  csvout.writerow(schedutils.format_event_csv(event, week, location))

if output:
  dest.close()
  typer.echo(f"Wrote schedule to {output}")
<<imports>>=
import csv
import sys
@

We keep the [[week]] and [[location]] switches for both rich and CSV output.
<<printing control options>>=
week: Annotated[bool, week_opt] = False,
<<argument and option definitions>>=
week_opt = typer.Option(help="Print week number and day of week")
@
<<printing control options>>=
location: Annotated[bool, location_opt] = True,
<<argument and option definitions>>=
location_opt = typer.Option(help="Print location of event")
@

Finally, CSV uses a configurable delimiter with tab as default.
<<printing control options>>=
delimiter: Annotated[str, delimiter_opt] = "\t",
<<argument and option definitions>>=
delimiter_opt = typer.Option(help="Delimiter for CSV output")
@

The [[--output]] option redirects CSV output to a named file.  Specifying
a file is equivalent to a non-TTY destination: the format auto-detects as
CSV and a header row is always written.
<<printing control options>>=
output: Annotated[Optional[str], output_opt] = None,
<<argument and option definitions>>=
output_opt = typer.Option("--output", "-o",
                          help="Write CSV output to file")
@


\section{Test setup}

We test the pure helper functions in this module.
The CLI commands themselves depend on course configuration and sign-up
sheets, making them harder to test in isolation.
The helper functions, however, contain important logic worth verifying.
<<test [[clischedule.py]]>>=
import datetime
from nytid.cli.schedule import *

<<test functions>>
@
