\chapter{The \texttt{cli.schedule} module and
         the \texttt{schedule} subcommands}%
\label{cli.schedule}

In this chapter we introduce the subcommands found under [[nytid schedule]],
it's the [[cli.schedule]] module.
<<[[schedule.py]]>>=
import datetime
from enum import Enum
import ics.event
import logging
import typer
import typerconf as config
from typing import List
from typing_extensions import Annotated

from nytid.cli import courses as coursescli
from nytid import courses as courseutils
from nytid import schedules as schedutils
from nytid.cli.signupsheets import SIGNUPSHEET_URL_PATH

<<imports>>
<<constants>>

cli = typer.Typer(name="schedule",
                  help="Working with course schedules")

<<helper functions>>
<<argument and option definitions>>
<<subcommands>>
@


\section{Default arguments for matching courses}

The first argument we need is to identify a set of courses.
For this we might also have to identify a set of registers.
We'll use the argument and option defined in the [[cli.courses]] module.
We'll default to all courses ([[.*]]) in the register of the [[mine]] command.
<<constants>>=
SCHEDULE_EXTERNAL_ICS_CONFIG = "schedule.external_ics"

TODO_WORK_START_CONFIG = "todo.work_start"
TODO_WORK_END_CONFIG = "todo.work_end"
TODO_WORK_DAYS_CONFIG = "todo.work_days"

DEFAULT_WORK_START = "08:00"
DEFAULT_WORK_END = "17:00"
DEFAULT_WORK_DAYS = "mon,tue,wed,thu,fri"
DEFAULT_ESTIMATED_HOURS = 1.0
@

<<argument for matching courses>>=
course: Annotated[str, coursescli.course_arg_regex]
<<option for matching registers, default to mine>>=
register: Annotated[str, coursescli.register_opt_regex] = coursescli.MINE
@

Then we can create a list of course--configuration pairs like this.
<<set list [[courses]] to ((course, register), config)-pairs>>=
registers = coursescli.registers_regex(register)
courses = {}
for course_reg in coursescli.courses_regex(course, registers):
  try:
    courses[course_reg] = courseutils.get_course_config(*course_reg)
  <<handle errors for accessing course data>>
<<handle errors for accessing course data>>=
except KeyError as err:
  logging.warning(err)
except PermissionError as err:
  course, register = course_reg
  logging.warning(f"You don't have access to {course} in {register}: {err}")
@

\section{My ICS, the \texttt{ics} command}

We want a command that outputs an ICS file that can be imported to a calendar, 
such as Google Calendar or Thunderbird.
The idea is to have a command such that you run
\begin{center}
[[nytid schedule ics > ~/public_html/nytid.ics]]
\end{center}
and then can import [[nytid.ics]] to the calendar through the public URL.
That way we can update it easily.
<<subcommands>>=
@cli.command(name="ics")
def ics_cmd(<<argument for matching courses>> = ".*",
            <<option for matching registers, default to mine>>,
            <<option for username to filter for>>):
  """
  Prints ICS data to stdout. Redirect to a .ics file, preferably in 
  ~/public_html, and add it to your calendar.
  """
  <<generate [[schedule]] from sign-up sheets for matching courses>>
  print(schedule.serialize())
<<generate [[schedule]] from sign-up sheets for matching courses>>=
<<set list [[courses]] to ((course, register), config)-pairs>>

schedule = ics.icalendar.Calendar()
<<set refresh rate for [[schedule]]>>
<<set refresh rate for [[schedule]], same as TimeEdit>>

booked = []
for (course, register), config in courses.items():
  try:
    <<fill [[booked]] or [[schedule]] for [[course]] with [[config]]>>
  except Exception as err:
    logging.error(f"Can't read sign-up sheet nor ICS for "
                  f"{course} ({register}): {err}")
    continue

<<add [[booked]] to [[schedule]]>>
<<set meta data for [[schedule]]>>
@

When we read in the bookings for a course, unlike before, we want to use the 
schedule if there is no sign-up sheet available.
If there is no sign-up sheet, we'll get a [[KeyError]] exception when we try to 
get its entry from the course's config.
In that case we use the schedule instead.
<<fill [[booked]] or [[schedule]] for [[course]] with [[config]]>>=
try:
  <<add to [[booked]] from [[course]] in [[register]] using [[config]]>>
except KeyError as err_signupsheet:
  logging.warning(f"Can't read sign-up sheet for {course} ({register}): "
                  f"{err_signupsheet}")
  <<read schedule from [[config]], add to [[schedule]]>>
@

To add the bookings of a course to [[booked]], we simply get the URL of the 
sign-up sheet and read the bookings.
<<add to [[booked]] from [[course]] in [[register]] using [[config]]>>=
url = config.get(SIGNUPSHEET_URL_PATH)
<<convert [[url]] to Google Sheet CSV-export URL if necessary>>
booked += sheets.read_signup_sheet_from_url(url)
<<imports>>=
from nytid.signup import sheets
@

If it's a Google Sheets sharing URL, we want to convert it to the export-CSV 
URL.
<<convert [[url]] to Google Sheet CSV-export URL if necessary>>=
if "docs.google.com" in url:
  url = sheets.google_sheet_to_csv_url(url)
@

We read the ICS URL from the course's config and then read it in and add it to 
[[schedule]].
We also run all the events from the schedule through a filter that removes 
events that are uninteresting.
For instance, we don't want to include events like holidays, exam weeks or 
fairs like KTH Global.
<<read schedule from [[config]], add to [[schedule]]>>=
course_schedule = schedutils.read_calendar(config.get("ics"))
schedule.events.update(schedutils.event_filter(course_schedule.events))
@

We need a username.
We will default to the username of the logged in user.
<<option for username to filter for>>=
user: Annotated[str, username_opt] = default_username
<<argument and option definitions>>=
try:
  default_username = os.environ["USER"]
except KeyError:
  default_username = None

username_opt = typer.Option(help="Username to filter sign-up sheet for, "
                                 "defaults to logged in user's username.")
<<imports>>=
import os
@

We will filter [[booked]] by the sought-after username, if there is one.
We also want to prefix a "RESERVE:" to the event if the person is a reserve and 
not booked to work.
Then we turn it into an ICS calendar object [[schedule]] as desired.
<<add [[booked]] to [[schedule]]>>=
if user:
  booked = sheets.filter_events_by_TA(user, booked)
  booked = map(functools.partial(add_reserve_to_title, user), booked)

schedule.events.update(set(map_drop_exceptions(sheets.EventFromCSV, booked)))
<<imports>>=
import functools
import ics.icalendar
<<helper functions>>=
def map_drop_exceptions(func, iterable):
  """
  Same as map, but ignores exceptions from `func`.
  Logs a warning when an item is dropped.
  """
  for item in iterable:
    try:
      yield func(item)
    except Exception as err:
      logging.warning(f"Dropped {item}: {err}")
@

Now, only that helper function remains.
It takes a TA and an event, checks if the TA is in the list of reserves, if so,
modifies the event to include "RESERVE:" in the title.
<<helper functions>>=
def add_reserve_to_title(ta, event):
  """
  Input: an event in CSV form.
  Ouput: the same CSV data, but with title prepended "RESERVE: " if TA is
  among the reserves.
  """
  _, reserves = sheets.get_booked_TAs_from_csv(event)
  if ta in reserves:
      event[0] = "RESERVE: " + event[0]

  return event
@

\paragraph{Testing [[map_drop_exceptions]]}

This function applies [[func]] to each item but silently drops items
where [[func]] raises an exception, logging a warning.
This is essential for robustness: a single malformed CSV row should not
crash the entire schedule export.
<<test functions>>=
def test_map_drop_exceptions_all_succeed():
  result = list(map_drop_exceptions(int, ["1", "2", "3"]))
  assert result == [1, 2, 3]

def test_map_drop_exceptions_some_fail():
  result = list(map_drop_exceptions(int, ["1", "bad", "3"]))
  assert result == [1, 3]

def test_map_drop_exceptions_all_fail():
  result = list(map_drop_exceptions(int, ["a", "b"]))
  assert result == []

def test_map_drop_exceptions_empty():
  result = list(map_drop_exceptions(int, []))
  assert result == []
@

\paragraph{Testing [[add_reserve_to_title]]}

If a TA is among the reserves (beyond the needed-TAs count), the event
title gets a \enquote{RESERVE:} prefix.
If the TA is booked (within the first N slots), the title stays
unchanged.
<<test functions>>=
def test_add_reserve_to_title_is_reserve():
  row = ["Lab", "2024-01-01 10:00", "2024-01-01 12:00",
         "D1", "1", "alice", "bob"]
  result = add_reserve_to_title("bob", row)
  assert result[0].startswith("RESERVE: ")

def test_add_reserve_to_title_is_booked():
  row = ["Lab", "2024-01-01 10:00", "2024-01-01 12:00",
         "D1", "1", "alice", "bob"]
  result = add_reserve_to_title("alice", row)
  assert not result[0].startswith("RESERVE:")
@

\subsection{Adding refresh interval to ICS output}

ICS supports specifying the refresh interval for a calendar\footnote{%
  See 
  \url{https://icalendar.org/New-Properties-for-iCalendar-RFC-7986/5-7-refresh-interval-property.html}.
  See also
  \url{https://lauren-c-stephen.medium.com/subscribe-to-an-icalendar-feed-in-google-calendar-and-solve-update-issues-79b4e84b3c64}.
}.
However, the ICS library we're using doesn't, but it supports custom properties 
that we can use.
We can set custom properties by using the [[.extra]] attribute.

There are seemingly two ways to do this, and we use both for maximum
client compatibility.
The standards-track approach is the [[REFRESH-INTERVAL]] property.
A complementary method, found by inspecting TimeEdit exports, is to set
method to [[PUBLISH]] and add a property [[X-PUBLISHED-TTL]]; some older
calendar clients only honour this vendor extension.
<<set refresh rate for [[schedule]]>>=
schedule.extra += [ContentLine("REFRESH-INTERVAL",
                               {"VALUE": ["DURATION"]},
                               "PT20M")]
<<set refresh rate for [[schedule]], same as TimeEdit>>=
schedule.method = "PUBLISH"
schedule.extra += [ContentLine("X-PUBLISHED-TTL", {}, "PT20M")]
<<imports>>=
from ics.grammar.parse import ContentLine
@

\subsection{Other metadata for ICS export}

Based on our observations from the TimeEdit exports, we can set other metadata 
in the calendar export.
<<set meta data for [[schedule]]>>=
schedule.name = "Nytid"
if user:
  schedule.name = f"{user}'s nytid"
schedule.extra += [ContentLine("X-WR-CALNAME", {}, schedule.name)]
schedule.description = "Nytid export"
if user:
  schedule.description = f"Nytid export for {user}"
schedule.extra += [ContentLine("X-WR-CALDESC", {}, schedule.description)]
@


\section{Showing the schedule, the \texttt{schedule show} command}

We want a command to just show the schedule in human readable format.
It should be able to include several courses.
We will use regex to match the courses and registers.
<<subcommands>>=
<<external calendar commands>>

@cli.command()
def show(<<argument for matching courses>> = ".*",
         <<option for matching registers, default to mine>>,
         <<option for username to filter for>>,
         <<default arguments for start and end dates>>,
         <<options for external calendar sources>>,
         <<printing control options>>):
  """
  Shows schedule for courses, external calendars and scheduled todos.
  """
  <<double check [[start]] and [[end]] dates>>
  <<generate [[schedule]] from sign-up sheets for matching courses>>
  <<add external calendar events to [[schedule]]>>
  <<add scheduled todo events to [[schedule]]>>
  <<print [[schedule]]>>
@

\subsection{Default arguments for start and end dates}

We'd also like to show only part of the schedule, given a start and end points.
We want to have today as the default start point and a week later as the 
default end point.
<<default arguments for start and end dates>>=
start: Annotated[datetime.datetime, start_date_opt]
  = str(datetime.date.today()),
end: Annotated[datetime.datetime, end_date_opt]
  = str(datetime.date.today() + datetime.timedelta(weeks=1))
<<argument and option definitions>>=
start_date_opt = typer.Option(help="The start date",
                              formats=["%Y-%m-%d"])
end_date_opt = typer.Option(help="The end date",
                            formats=["%Y-%m-%d"])
@

If we change the start date, but not the end date, the end date might be before 
the start date.
A user will likely expect that if they update only the start date, the end date 
will still be a week after the start date.
<<helper functions>>=
def update_end_date(start, end):
  """
  Returns a correct end date.
  """
  if end < start:
    return start + datetime.timedelta(weeks=1)
  return end
<<double check [[start]] and [[end]] dates>>=
end = update_end_date(start, end)
@

\paragraph{Testing [[update_end_date]]}

When a user changes the start date but not the end date, the end date
may be before the start.
In that case, [[update_end_date]] returns start + 1 week.
Otherwise it returns the original end.
<<test functions>>=
def test_update_end_date_end_before_start():
  start = datetime.datetime(2024, 6, 1)
  end = datetime.datetime(2024, 1, 1)
  result = update_end_date(start, end)
  assert result == start + datetime.timedelta(weeks=1)

def test_update_end_date_end_after_start():
  start = datetime.datetime(2024, 1, 1)
  end = datetime.datetime(2024, 6, 1)
  result = update_end_date(start, end)
  assert result == end

def test_update_end_date_equal():
  start = datetime.datetime(2024, 3, 1)
  end = datetime.datetime(2024, 3, 1)
  result = update_end_date(start, end)
  assert result == end
@

\subsection{Managing external calendars}

External calendars can be added once and reused in every
[[schedule show]] run.
These events are both displayed and used as occupied time when scheduling todos.
<<external calendar commands>>=
externalcli = typer.Typer(name="external",
                          help="Manage external ICS calendars")
cli.add_typer(externalcli)

@externalcli.command(name="add")
def external_add(source: str):
  """
  Adds an external ICS URL or file path.
  """
  sources = get_external_sources()
  if source in sources:
    print(source)
    return

  sources.append(source)
  set_external_sources(sources)
  print(source)

@externalcli.command(name="ls")
def external_ls():
  """
  Lists configured external ICS URL:s/file paths.
  """
  for source in get_external_sources():
    print(source)

@externalcli.command(name="rm")
def external_rm(source: str):
  """
  Removes an external ICS URL or file path.
  """
  sources = [s for s in get_external_sources() if s != source]
  set_external_sources(sources)
  print(source)
@

To support scripts and one-off runs, [[schedule show]] can include additional
external sources directly from the command line.
<<options for external calendar sources>>=
external: Annotated[List[str], external_opt] = None
<<argument and option definitions>>=
external_opt = typer.Option("--external", "-x",
                            help="Additional ICS URL or file path")
@

The configured path is a list value in config, but we also accept a single
string value for convenience.
<<helper functions>>=
def as_list(value):
  """
  Coerces a config value to a list of strings.
  """
  if value is None:
    return []
  if isinstance(value, list):
    return [str(v) for v in value if str(v).strip()]

  value = str(value).strip()
  if not value:
    return []

  return [value]

def get_external_sources(cli_sources=None):
  """
  Returns configured external sources merged with CLI-provided ones.
  """
  sources = []
  try:
    sources.extend(as_list(config.get(SCHEDULE_EXTERNAL_ICS_CONFIG)))
  except KeyError:
    pass

  if cli_sources:
    sources.extend(as_list(cli_sources))

  return list(dict.fromkeys(sources))

def set_external_sources(sources):
  """
  Persists external ICS sources.
  """
  config.set(SCHEDULE_EXTERNAL_ICS_CONFIG,
             list(dict.fromkeys(sources)))
@

\paragraph{Testing [[as_list]]}

Configuration values may be missing, scalar, or lists.
We normalize these to a list of non-empty strings.
<<test functions>>=
def test_as_list_none():
  assert as_list(None) == []

def test_as_list_string():
  assert as_list("https://example.com/cal.ics") == [
    "https://example.com/cal.ics"
  ]

def test_as_list_list():
  assert as_list(["a", "", "b"]) == ["a", "b"]
@

\subsection{Scheduling todos around occupied time}

We combine all visible events into one occupied timeline and schedule todos in
the remaining work-hour slots.
<<helper functions>>=
def local_naive(dt):
  """
  Converts datetime to local naive time for safe comparisons.
  """
  if dt.tzinfo:
    return dt.astimezone().replace(tzinfo=None)
  return dt

def event_bounds(events):
  """
  Converts events to (start, end) datetime pairs.
  """
  bounds = []
  for event in events:
    if not event.begin or not event.end:
      continue
    begin = local_naive(event.begin.datetime)
    end = local_naive(event.end.datetime)
    if end > begin:
      bounds.append((begin, end))

  return bounds
@

\paragraph{Testing [[local_naive]] and [[event_bounds]]}

The [[local_naive]] function must handle both timezone-aware and naive
datetimes, since ICS events may arrive in either form.
The [[event_bounds]] function converts events to plain start/end pairs,
skipping any events that lack either endpoint.
<<test functions>>=
def test_local_naive_with_naive_datetime():
  dt = datetime.datetime(2024, 6, 1, 10, 0)
  assert local_naive(dt) == dt

def test_local_naive_with_aware_datetime():
  import zoneinfo
  tz = zoneinfo.ZoneInfo("UTC")
  dt = datetime.datetime(2024, 6, 1, 10, 0, tzinfo=tz)
  result = local_naive(dt)
  assert result.tzinfo is None

def test_event_bounds_skips_missing_times():
  class FakeEvent:
    def __init__(self, begin, end):
      self.begin = begin
      self.end = end

  class FakeArrow:
    def __init__(self, dt):
      self._dt = dt
    @property
    def datetime(self):
      return self._dt

  e1 = FakeEvent(
    FakeArrow(datetime.datetime(2024, 1, 1, 9, 0)),
    FakeArrow(datetime.datetime(2024, 1, 1, 10, 0)),
  )
  e2 = FakeEvent(None, FakeArrow(datetime.datetime(2024, 1, 1, 11, 0)))

  result = event_bounds([e1, e2])
  assert len(result) == 1
  assert result[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 10, 0),
  )
@

\paragraph{Testing [[compute_free_slots]]}

Free-slot computation is the core scheduling algorithm.
Given a set of occupied intervals and a date range, it returns the
gaps during work hours.
We test with a fixed work window to avoid dependency on configuration.
<<test functions>>=
def test_compute_free_slots_no_events(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "12:00", ["mon"]),
  )
  # 2024-01-01 is a Monday
  start = datetime.datetime(2024, 1, 1, 0, 0)
  end = datetime.datetime(2024, 1, 1, 23, 59)

  # Freeze "now" to the start of the day so it doesn't
  # clip the work window.
  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  slots = compute_free_slots([], start, end)
  assert len(slots) == 1
  assert slots[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 12, 0),
  )

def test_compute_free_slots_with_event(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "12:00", ["mon"]),
  )
  start = datetime.datetime(2024, 1, 1, 0, 0)
  end = datetime.datetime(2024, 1, 1, 23, 59)

  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  occupied = [
    (datetime.datetime(2024, 1, 1, 10, 0),
     datetime.datetime(2024, 1, 1, 11, 0)),
  ]
  slots = compute_free_slots(occupied, start, end)
  assert len(slots) == 2
  assert slots[0] == (
    datetime.datetime(2024, 1, 1, 9, 0),
    datetime.datetime(2024, 1, 1, 10, 0),
  )
  assert slots[1] == (
    datetime.datetime(2024, 1, 1, 11, 0),
    datetime.datetime(2024, 1, 1, 12, 0),
  )

def test_compute_free_slots_skips_non_work_days(monkeypatch):
  monkeypatch.setattr(
    "nytid.cli.schedule.work_window",
    lambda: ("09:00", "17:00", ["mon"]),
  )
  # 2024-01-02 is a Tuesday
  start = datetime.datetime(2024, 1, 2, 0, 0)
  end = datetime.datetime(2024, 1, 2, 23, 59)

  monkeypatch.setattr(
    "nytid.cli.schedule.datetime",
    type("dt", (), {
      "datetime": type("inner", (), {
        "now": staticmethod(lambda: start),
        "combine": datetime.datetime.combine,
      }),
      "timedelta": datetime.timedelta,
      "time": datetime.time,
      "date": datetime.date,
    }),
  )

  slots = compute_free_slots([], start, end)
  assert slots == []
@

We use the same work-hour settings as [[todo]], so planning behaviour is
consistent across the CLI.
<<helper functions>>=
def work_window():
  """
  Returns (work_start, work_end, work_days).
  """
  try:
    work_start = config.get(TODO_WORK_START_CONFIG)
  except KeyError:
    work_start = DEFAULT_WORK_START

  try:
    work_end = config.get(TODO_WORK_END_CONFIG)
  except KeyError:
    work_end = DEFAULT_WORK_END

  try:
    work_days = config.get(TODO_WORK_DAYS_CONFIG)
  except KeyError:
    work_days = DEFAULT_WORK_DAYS

  if isinstance(work_days, list):
    work_days = ",".join(str(day) for day in work_days)

  work_days = [d.strip().lower() for d in work_days.split(",")]
  return work_start, work_end, work_days

def compute_free_slots(occupied, start, end):
  """
  Returns free slots in [start, end] during work hours.
  """
  work_start, work_end, work_days = work_window()

  start_h, start_m = map(int, work_start.split(":"))
  end_h, end_m = map(int, work_end.split(":"))

  day_names = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]
  now = datetime.datetime.now()
  free_slots = []

  date = start.date()
  while date <= end.date():
    day_name = day_names[date.weekday()]
    if day_name not in work_days:
      date += datetime.timedelta(days=1)
      continue

    day_start = datetime.datetime.combine(
      date,
      datetime.time(start_h, start_m),
    )
    day_end = datetime.datetime.combine(
      date,
      datetime.time(end_h, end_m),
    )

    day_start = max(day_start, start)
    day_end = min(day_end, end)

    if date == now.date() and now > day_start:
      day_start = now.replace(second=0, microsecond=0)

    if day_start >= day_end:
      date += datetime.timedelta(days=1)
      continue

    day_events = sorted(
      [
        (max(s, day_start), min(e, day_end))
        for s, e in occupied
        if s < day_end and e > day_start
      ],
      key=lambda x: x[0],
    )

    cursor = day_start
    for event_start, event_end in day_events:
      if cursor < event_start:
        free_slots.append((cursor, event_start))
      cursor = max(cursor, event_end)

    if cursor < day_end:
      free_slots.append((cursor, day_end))

    date += datetime.timedelta(days=1)

  return free_slots
@

Todo scheduling uses the same priority model as [[todo ls]]: we sort by
effective priority and greedily fill the earliest free slots.
<<helper functions>>=
def schedule_todo_events(user, start, end, occupied):
  """
  Returns VEVENTs for scheduled todos.
  """
  from nytid.cli import todo as todocli

  _, todos = todocli.load_todos()
  todos = [t for t in todos if t.status != "done"]

  if user:
    todos = [t for t in todos if t.who == user]

  if not todos:
    return []

  free_slots = compute_free_slots(occupied, start, end)
  if not free_slots:
    return []

  now = datetime.datetime.now()
  todos.sort(
    key=lambda t: todocli.effective_priority(t, now),
    reverse=True,
  )

  scheduled_events = []
  remaining_slots = list(free_slots)

  for item in todos:
    hours_needed = item.estimated or DEFAULT_ESTIMATED_HOURS
    while hours_needed > 0 and remaining_slots:
      slot_start, slot_end = remaining_slots[0]
      slot_hours = (slot_end - slot_start).total_seconds() / 3600
      if slot_hours <= 0:
        remaining_slots.pop(0)
        continue

      if hours_needed >= slot_hours:
        event_end = slot_end
        hours_needed -= slot_hours
        remaining_slots.pop(0)
      else:
        event_end = slot_start + datetime.timedelta(hours=hours_needed)
        remaining_slots[0] = (event_end, slot_end)
        hours_needed = 0

      event = ics.event.Event()
      event.name = f"[TODO] {item.title}"
      event.begin = slot_start
      event.end = event_end
      event.location = "TODO"
      if item.description:
        event.description = item.description
      elif item.labels:
        event.description = "; ".join(item.labels)
      else:
        event.description = ""
      scheduled_events.append(event)

  return scheduled_events
@

Once we have the course schedule, we merge external calendars and then
schedule todos into the remaining free slots.
The order matters: external calendar events must be merged \emph{before}
we compute free slots for todos, because [[compute_free_slots]] treats
every event already in [[schedule]] as occupied time.
If we scheduled todos first, they would overlap with external commitments
that hadn't been added yet.
<<add external calendar events to [[schedule]]>>=
external_sources = get_external_sources(external)
external_calendar = schedutils.read_calendars(external_sources)
schedule.events.update(external_calendar.events)
@

With all occupied time now in [[schedule]], we extract the busy intervals
and greedily fill the remaining work-hour slots with todos, sorted by
effective priority.
<<add scheduled todo events to [[schedule]]>>=
occupied = event_bounds(schedule.events)
schedule.events.update(schedule_todo_events(user,
                                            start,
                                            end,
                                            occupied))
@

\subsection{Filter events based on start--end time}

Before output, we keep only events overlapping the chosen interval.
<<set [[events]] to filtered timeline>>=
events = []
for event in schedule.timeline:
  if event.end.date() < start.date():
    continue
  if event.begin.date() > end.date():
    continue
  events.append(event)
@

\subsection{Output format}

Like [[todo ls]], we use auto-format by default: rich table in a terminal,
tab-separated CSV when piped.
<<argument and option definitions>>=
class OutputFormat(str, Enum):
  table = "table"
  rich = "rich"
  csv = "csv"

output_format_opt = typer.Option("--format", "-f",
                                 help="Output format: table, rich or csv",
                                 case_sensitive=False)
@
<<printing control options>>=
output_format: Annotated[OutputFormat, output_format_opt] = "table",

<<determine effective output format>>=
if output_format == OutputFormat.table:
  effective_output_format = "rich" if sys.stdout.isatty() else "csv"
elif output_format == OutputFormat.rich:
  effective_output_format = "rich"
else:
  effective_output_format = "csv"
@

\subsection{Printing the events}

We print either a rich table or CSV based on the effective format.
<<print [[schedule]]>>=
<<set [[events]] to filtered timeline>>
<<determine effective output format>>

if effective_output_format == "rich":
  <<print [[events]] as rich table>>
else:
  <<print [[events]] as CSV>>
@

For rich output we display the same core fields as in CSV, but with aligned
columns for interactive reading.
<<print [[events]] as rich table>>=
from rich.console import Console
from rich import box
from rich.table import Table

console = Console()
table = Table(show_header=True,
              header_style="bold",
              box=box.SIMPLE,
              show_edge=False,
              pad_edge=False)
table.add_column("When")
table.add_column("Event")
if location:
  table.add_column("Location")
table.add_column("Description")

for event in events:
  row = schedutils.format_event_csv(event, week=week, location=True)
  if week:
    when = f"{row[0]} {row[1]}"
    title = row[2]
    where = row[3]
    description = row[4]
  else:
    when = row[0]
    title = row[1]
    where = row[2]
    description = row[3]

  if location:
    table.add_row(when, title, where, description)
  else:
    table.add_row(when, title, description)

console.print(table)
@

CSV is always tab-separated by default, so shell tools can process it directly.
<<print [[events]] as CSV>>=
csvout = csv.writer(sys.stdout, delimiter=delimiter)

header = []
if week:
  header.append("week_day")
header += ["start", "event"]
if location:
  header.append("location")
header.append("description")
csvout.writerow(header)

for event in events:
  csvout.writerow(schedutils.format_event_csv(event, week, location))
<<imports>>=
import csv
import sys
@

We keep the [[week]] and [[location]] switches for both rich and CSV output.
<<printing control options>>=
week: Annotated[bool, week_opt] = False,
<<argument and option definitions>>=
week_opt = typer.Option(help="Print week number and day of week")
@
<<printing control options>>=
location: Annotated[bool, location_opt] = True,
<<argument and option definitions>>=
location_opt = typer.Option(help="Print location of event")
@

Finally, CSV uses a configurable delimiter with tab as default.
<<printing control options>>=
delimiter: Annotated[str, delimiter_opt] = "\t",
<<argument and option definitions>>=
delimiter_opt = typer.Option(help="Delimiter for CSV output")
@


\section{Test setup}

We test the pure helper functions in this module.
The CLI commands themselves depend on course configuration and sign-up
sheets, making them harder to test in isolation.
The helper functions, however, contain important logic worth verifying.
<<test [[clischedule.py]]>>=
import datetime
from nytid.cli.schedule import *

<<test functions>>
@
