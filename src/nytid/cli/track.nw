\chapter{The \texttt{cli.track} module and
         the \texttt{track} subcommands}%
\label{cli.track}

In this chapter we introduce the subcommands found under [[nytid track]],
it's the [[cli.track]] module for time tracking functionality.

\section{Design Overview and Rationale}

The track command allows teachers to track time spent on various course-related activities
such as meetings, grading, preparation time, lectures, etc. The system is designed around
several key principles:

\subsection{Flat Label System}
The core design uses independent labels (tags) to categorize work. Labels are flat, not 
hierarchical, allowing maximum flexibility in organizing and filtering tracked time.
For example, tracking with labels [[DD1310]], [[lecture]], [[preparation]] creates three
independent tags that can be started and stopped individually:
\begin{itemize}
\item Each label tracks independently
\item Labels can be stopped in any order
\item Same label cannot track twice in parallel (attempting to start it again just continues existing tracking)
\item Labels can be combined for multi-dimensional categorization
\end{itemize}

This allows for flexible reporting and analysis, such as:
\begin{itemize}
\item All time spent on [[DD1310]] (regardless of activity)
\item All [[lecture]] time (regardless of course)
\item Time spent on [[DD1310]] AND [[lecture]] (intersection)
\end{itemize}

\subsection{Independent Label Tracking}
Each label in an active session tracks time independently with its own start time.
Labels can be:
\begin{itemize}
\item Started individually or in groups
\item Stopped individually or in groups
\item Annotated with notes at any time
\item Queried to see current status
\end{itemize}

\subsection{Persistent Data Storage}
All tracking data is persisted in JSON format using nytid's StorageRoot system for
consistency with other nytid components. The system maintains two separate data files:
\begin{itemize}
\item \textbf{Completed entries}: Historical tracking data for analysis and export
\item \textbf{Active session}: Current tracking state that survives application restarts
\end{itemize}

\subsection{Multi-format Export Capability}
The system supports multiple export formats (ICS, JSON, CSV) to integrate with different
tools and workflows that teachers use for time management and reporting.

\section{Code Outline}

The main module structure follows nytid's standard patterns:

<<track.py>>=
import datetime
import json
import logging
import os
import pathlib
import sys
import subprocess
import typer
import typerconf as config
from typing_extensions import Annotated
from typing import List, Optional, Dict
import time

from nytid import storage

<<configuration management>>

cli = typer.Typer(name="track",
                  help="Track time spent on course activities")

<<helper functions>>
<<data structures>>
<<tracking state management>>
<<subcommands>>
@

\section{Configuration Management}

The track system uses nytid's configuration system (via typerconf) to store user
preferences and data locations, making it configurable and consistent with other
nytid components.

The track system supports the following configuration options:

\begin{description}
\item[\texttt{track.data\_dir}] Directory where tracking data is stored. 
  Defaults to \texttt{\~{}/.nytid/tracking} if not configured.
\item[\texttt{track.weekly\_limit}] Default weekly hour limit for warnings in statistics. 
  Defaults to 40.0 hours if not configured.
\item[\texttt{track.daily\_limit}] Default daily hour limit for warnings in statistics. 
  Defaults to 8.0 hours if not configured.
\end{description}

To customize the track system, use the standard nytid config commands:

\begin{minted}{bash}
# Set custom data directory
nytid config track.data_dir -s /path/to/custom/tracking/data

# Set weekly hour limit for work-life balance warnings  
nytid config track.weekly_limit -s 35.0

# Set daily hour limit warnings
nytid config track.daily_limit -s 7.5

# View current track configuration
nytid config track.data_dir
nytid config track.weekly_limit  
nytid config track.daily_limit
\end{minted}

The configuration system ensures that track settings are persistent and can be
customized per user or per course context, following nytid's standard patterns.

We use nytid's StorageRoot system for managing tracking data files, which provides
a consistent interface with other nytid components and supports different storage
backends (local filesystem, AFS, etc.).

<<configuration management>>=
# Configuration keys for track system
TRACKING_DIR_CONFIG = "track.data_dir"
DEFAULT_WEEKLY_LIMIT_CONFIG = "track.weekly_limit"
DEFAULT_DAILY_LIMIT_CONFIG = "track.daily_limit"

def get_tracking_storage() -> storage.StorageRoot:
    """
    Get the StorageRoot for tracking data.
    
    Uses nytid's StorageRoot system for consistent file management.
    Returns a StorageRoot object that can be used to open tracking data files.
    """
    try:
        tracking_dir = pathlib.Path(config.get(TRACKING_DIR_CONFIG))
    except KeyError:
        # Fallback to default location in user's home directory
        tracking_dir = pathlib.Path.home() / ".nytid" / "tracking"
        # Set the default in config for future use
        config.set(TRACKING_DIR_CONFIG, str(tracking_dir))
    
    return storage.StorageRoot(tracking_dir)

def get_tracking_dir() -> pathlib.Path:
    """Get the tracking data directory path (for compatibility)"""
    return get_tracking_storage()._StorageRoot__path

def get_tracking_data_file() -> pathlib.Path:
    """Get the path to the tracking data file"""
    return get_tracking_dir() / "tracking_data.json"

def get_current_session_file() -> pathlib.Path:
    """Get the path to the current session file"""
    return get_tracking_dir() / "current_session.json"

def get_default_weekly_limit() -> float:
    """Get the default weekly hour limit from config"""
    try:
        return float(config.get(DEFAULT_WEEKLY_LIMIT_CONFIG))
    except (KeyError, ValueError):
        return 40.0  # Default to 40 hours per week

def get_default_daily_limit() -> float:
    """Get the default daily hour limit from config"""
    try:
        return float(config.get(DEFAULT_DAILY_LIMIT_CONFIG))
    except (KeyError, ValueError):
        return 8.0  # Default to 8 hours per day
@

\section{Helper Functions}

We need some utility functions for formatting and display.

<<helper functions>>=
def format_duration(duration: datetime.timedelta) -> str:
    """Format a duration in a human-readable way"""
    total_seconds = int(duration.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    
    if hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def get_labels_display(labels: List[str]) -> str:
    """Get a display string for labels (as comma-separated tags)"""
    return ", ".join(sorted(labels)) if labels else "No labels"
@

\section{Data Structures and Class Architecture}

The tracking system is built around two main classes that work together to provide
a complete time tracking solution with flat, independent labels.

\subsection{TrackingEntry Class}

The [[TrackingEntry]] class represents a completed time tracking session. It encapsulates
all the information about a single period of tracked work: when it started and ended,
what labels (tags) it had, and any descriptive notes.

This class serves as the fundamental data unit for historical tracking data. It provides:
\begin{itemize}
\item \textbf{Immutable record}: Once created, entries represent completed work sessions
\item \textbf{Duration calculation}: Automatic computation of time spent
\item \textbf{Serialization support}: JSON conversion for persistent storage
\item \textbf{Flat labels}: Maintains independent labels (tags) for flexible categorization
\end{itemize}

<<tracking entry class>>=
class TrackingEntry:
    """
    Represents a completed time tracking entry.
    
    This class encapsulates all information about a single tracked work session,
    including the time span, flat labels (tags), and optional description.
    Once created, instances are immutable records of completed work.
    """
    
    def __init__(self, start_time: datetime.datetime, end_time: datetime.datetime, 
                 labels: List[str], description: str = ""):
        """
        Initialize a tracking entry.
        
        Args:
            start_time: When the tracked work began
            end_time: When the tracked work ended  
            labels: List of independent labels/tags (e.g., ['DD1310', 'lecture', 'prep'])
            description: Optional description of the work performed
        """
        self.start_time = start_time
        self.end_time = end_time
        self.labels = sorted(list(set(labels)))  # Ensure unique and sorted
        self.description = description
        
    def duration(self) -> datetime.timedelta:
        """
        Calculate the duration of this tracking entry.
        
        Returns:
            The time difference between end_time and start_time
        """
        return self.end_time - self.start_time
        
    def to_dict(self) -> dict:
        """
        Convert to dictionary for JSON serialization.
        
        Returns:
            Dictionary with all entry data in JSON-serializable format
        """
        return {
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat(),
            'labels': self.labels,
            'description': self.description
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'TrackingEntry':
        """
        Create from dictionary (JSON deserialization).
        
        Args:
            data: Dictionary containing serialized entry data
            
        Returns:
            New TrackingEntry instance
        """
        return cls(
            start_time=datetime.datetime.fromisoformat(data['start_time']),
            end_time=datetime.datetime.fromisoformat(data['end_time']),
            labels=data['labels'],
            description=data.get('description', '')
        )
@

\subsubsection{Testing TrackingEntry}

We test the [[TrackingEntry]] class to ensure duration calculation and serialization work correctly.

<<test tracking entry>>=
def test_tracking_entry_duration():
    """Test TrackingEntry duration calculation"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 30, 0)
    entry = TrackingEntry(start, end, ["test"], "test entry")
    
    duration = entry.duration()
    assert duration.total_seconds() == 5400  # 1.5 hours

def test_tracking_entry_serialization():
    """Test TrackingEntry to/from dict conversion"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 0, 0)
    entry = TrackingEntry(start, end, ["DD1310", "lecture"], "test")
    
    data = entry.to_dict()
    assert data["labels"] == ["DD1310", "lecture"]
    assert data["description"] == "test"
    
    # Test round-trip
    entry2 = TrackingEntry.from_dict(data)
    assert entry2.start_time == entry.start_time
    assert entry2.end_time == entry.end_time
    assert entry2.labels == entry.labels
    assert entry2.description == entry.description
@

\subsection{ActiveSession Class}

The [[ActiveSession]] class manages the current tracking state with independent labels.
Instead of a stack, it maintains a dictionary of actively tracked labels, each with
its own start time and optional notes.

The flat label design provides maximum flexibility:
\begin{itemize}
\item \textbf{Independent tracking}: Each label tracks independently with its own start time
\item \textbf{Any-order removal}: Labels can be stopped in any order
\item \textbf{Duplicate prevention}: Starting an existing label continues current tracking
\item \textbf{Annotations}: Notes can be added to any active label at any time
\item \textbf{Persistent state}: Session survives application restarts
\end{itemize}

The two classes interact in a producer-consumer pattern:
\begin{itemize}
\item [[ActiveSession]] \textbf{produces} [[TrackingEntry]] objects when labels are stopped
\item [[TrackingEntry]] objects are \textbf{consumed} by the storage and analysis functions
\item Both classes use the same flat label format for consistency
\item Both support JSON serialization using the same patterns
\end{itemize}

<<active session class>>=
class ActiveSession:
    """
    Manages the current tracking state with independent flat labels.
    
    This class maintains a dictionary of currently active tracking labels,
    where each label tracks independently with its own start time and notes.
    Labels can be started, stopped, and annotated independently.
    """
    
    def __init__(self):
        """Initialize an empty active session."""
        # Dictionary mapping label -> (start_time, notes)
        self.active_labels: Dict[str, tuple] = {}
        
    def start_labels(self, labels: List[str], start_time: datetime.datetime) -> List[str]:
        """
        Start tracking for the given labels.
        
        If a label is already being tracked, it's ignored (continues existing tracking).
        This prevents duplicate tracking of the same label.
        
        Args:
            labels: List of labels to start tracking
            start_time: When tracking of these labels began
            
        Returns:
            List of labels that were actually started (excludes already-active labels)
        """
        started = []
        for label in labels:
            if label not in self.active_labels:
                self.active_labels[label] = (start_time, "")
                started.append(label)
        return started
    
    def stop_labels(self, labels: List[str] = None, end_time: datetime.datetime = None) -> List[TrackingEntry]:
        """
        Stop tracking for specified labels and return completed entries.
        
        Args:
            labels: List of labels to stop. If None, stops all active labels.
            end_time: When tracking ended. If None, uses current time.
            
        Returns:
            List of TrackingEntry objects for the stopped labels
        """
        if end_time is None:
            end_time = datetime.datetime.now()
            
        if labels is None:
            labels = list(self.active_labels.keys())
            
        entries = []
        for label in labels:
            if label in self.active_labels:
                start_time, notes = self.active_labels.pop(label)
                # Create entry with just this label
                entry = TrackingEntry(start_time, end_time, [label], notes)
                entries.append(entry)
                
        return entries
    
    def add_notes(self, label: str, notes: str) -> bool:
        """
        Add or update notes for an active label.
        
        Args:
            label: The label to annotate
            notes: The notes/description to add
            
        Returns:
            True if notes were added, False if label is not active
        """
        if label in self.active_labels:
            start_time, _ = self.active_labels[label]
            self.active_labels[label] = (start_time, notes)
            return True
        return False
    
    def get_active_labels(self) -> List[str]:
        """
        Get list of currently active labels.
        
        Returns:
            Sorted list of active label names
        """
        return sorted(self.active_labels.keys())
    
    def get_label_info(self, label: str) -> Optional[tuple]:
        """
        Get information about a specific active label.
        
        Args:
            label: The label to query
            
        Returns:
            Tuple of (start_time, notes) if label is active, None otherwise
        """
        return self.active_labels.get(label)
    
    def is_active(self) -> bool:
        """
        Check if there are any active tracking labels.
        
        Returns:
            True if any labels are being tracked, False otherwise
        """
        return len(self.active_labels) > 0
    
    def to_dict(self) -> dict:
        """
        Convert to dictionary for JSON serialization.
        
        Returns:
            Dictionary with session state in JSON-serializable format
        """
        return {
            'active_labels': {
                label: (start_time.isoformat(), notes)
                for label, (start_time, notes) in self.active_labels.items()
            }
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'ActiveSession':
        """
        Create from dictionary (JSON deserialization).
        
        Args:
            data: Dictionary containing serialized session data
            
        Returns:
            New ActiveSession instance with restored state
        """
        session = cls()
        active_labels_data = data.get('active_labels', {})
        
        # Handle both old format (label_stack) and new format (active_labels)
        if 'label_stack' in data and not active_labels_data:
            # Convert old hierarchical format to flat labels
            for label, start_time_str in data['label_stack']:
                start_time = datetime.datetime.fromisoformat(start_time_str)
                session.active_labels[label] = (start_time, "")
        else:
            # Use new flat format
            for label, (start_time_str, notes) in active_labels_data.items():
                start_time = datetime.datetime.fromisoformat(start_time_str)
                session.active_labels[label] = (start_time, notes)
        
        return session
@
        session.label_stack = [
            (label, datetime.datetime.fromisoformat(start_time))
            for label, start_time in data.get('label_stack', [])
        ]
        return session
@

\subsubsection{Testing ActiveSession}

We test the [[ActiveSession]] operations to ensure flat label tracking works correctly.

<<test active session>>=
def test_active_session_operations():
    """Test ActiveSession with flat label operations"""
    session = ActiveSession()
    start_time = datetime.datetime.now()
    
    # Test starting labels
    started = session.start_labels(["DD1310", "lecture"], start_time)
    assert set(started) == {"DD1310", "lecture"}
    assert set(session.get_active_labels()) == {"DD1310", "lecture"}
    assert session.is_active()
    
    # Test that starting same label again doesn't duplicate
    started = session.start_labels(["DD1310"], start_time)
    assert started == []  # Already tracking DD1310
    assert set(session.get_active_labels()) == {"DD1310", "lecture"}
    
    # Test adding notes
    assert session.add_notes("DD1310", "Course meeting notes")
    assert session.add_notes("nonexistent", "Should fail") == False
    
    # Test stopping specific label
    entries = session.stop_labels(["lecture"])
    assert len(entries) == 1
    assert entries[0].labels == ["lecture"]
    assert session.get_active_labels() == ["DD1310"]
    
    # Test stopping all remaining
    entries = session.stop_labels()
    assert len(entries) == 1
    assert entries[0].labels == ["DD1310"]
    assert entries[0].description == "Course meeting notes"
    assert not session.is_active()
@

Now we combine both classes in the data structures chunk:

<<data structures>>=
<<tracking entry class>>
<<active session class>>
@

\section{Tracking State Management}

The state management functions provide the interface between the in-memory data structures
and persistent storage. They handle file I/O, error recovery, and ensure data consistency.

The state management follows these principles:
\begin{itemize}
\item \textbf{Graceful degradation}: Missing or corrupted files don't crash the system
\item \textbf{Automatic recovery}: Invalid data is logged and ignored, allowing continued operation
\item \textbf{Lazy initialization}: Directories and files are created only when needed
\item \textbf{Configuration integration}: File locations respect user configuration
\end{itemize}

\subsection{Directory Management}

We need to ensure the tracking directory exists before writing files.

<<ensure tracking dir>>=
def ensure_tracking_dir():
    """
    Ensure the tracking directory exists.
    
    Creates the tracking data directory if it doesn't exist, including
    any necessary parent directories. Uses the configured location.
    """
    get_tracking_dir().mkdir(parents=True, exist_ok=True)
@

\subsection{Historical Data Management}

Historical tracking data is stored in JSON format for all completed time entries.

<<load tracking data>>=
def load_tracking_data() -> List[TrackingEntry]:
    """
    Load historical tracking data from the persistent storage file.
    
    Returns:
        List of TrackingEntry objects, or empty list if file doesn't exist
        or contains invalid data
    """
    tracking_file = get_tracking_data_file()
    if not tracking_file.exists():
        return []
    
    try:
        with open(tracking_file, 'r') as f:
            data = json.load(f)
            return [TrackingEntry.from_dict(entry) for entry in data]
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading tracking data from {tracking_file}: {e}")
        return []

def save_tracking_data(entries: List[TrackingEntry]):
    """
    Save tracking data to persistent storage.
    
    Args:
        entries: List of TrackingEntry objects to save
    """
    ensure_tracking_dir()
    tracking_file = get_tracking_data_file()
    with open(tracking_file, 'w') as f:
        json.dump([entry.to_dict() for entry in entries], f, indent=2)

def add_completed_entries(new_entries: List[TrackingEntry]):
    """
    Add newly completed entries to the historical tracking data.
    
    This function implements an append-only approach to maintain data integrity.
    It loads existing data, appends new entries, and saves the combined dataset.
    
    Args:
        new_entries: List of TrackingEntry objects to add to historical data
    """
    if not new_entries:
        return
        
    existing_entries = load_tracking_data()
    existing_entries.extend(new_entries)
    save_tracking_data(existing_entries)
@

\subsection{Active Session Management}

The active session maintains the current tracking state and survives application restarts.

<<session management>>=
def load_active_session() -> ActiveSession:
    """
    Load the current active session from persistent storage.
    
    Returns:
        ActiveSession object with restored state, or empty session if
        file doesn't exist or contains invalid data
    """
    session_file = get_current_session_file()
    if not session_file.exists():
        return ActiveSession()
    
    try:
        with open(session_file, 'r') as f:
            data = json.load(f)
            return ActiveSession.from_dict(data)
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading active session from {session_file}: {e}")
        return ActiveSession()

def save_active_session(session: ActiveSession):
    """
    Save the current active session to persistent storage.
    
    Args:
        session: ActiveSession object to save
    """
    ensure_tracking_dir()
    session_file = get_current_session_file()
    with open(session_file, 'w') as f:
        json.dump(session.to_dict(), f, indent=2)
@

Now we combine all state management functions:

<<tracking state management>>=
<<ensure tracking dir>>
<<load tracking data>>
<<session management>>
@

\section{Subcommands}

Now we implement the various subcommands for the track functionality. Each command
is organized with its documentation, implementation, and tests together.

\subsection{Status Command}

The status command shows what is currently being tracked. This is typically the
first command users run to see if any tracking is active.

<<status command>>=
@cli.command()
def status():
    """
    Show current tracking status.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking")
        return
    
    typer.echo("Currently tracking:")
    current_time = datetime.datetime.now()
    
    for i, (label, start_time) in enumerate(session.label_stack):
        duration = current_time - start_time
        indent = "  " * i
        typer.echo(f"{indent}- {label} (for {format_duration(duration)})")
    
    total_labels = session.get_current_labels()
    typer.echo(f"\nFull label hierarchy: {get_labels_display(total_labels)}")
@

\subsubsection{Testing Status Command}

<<test status command>>=
def test_status_no_tracking(temp_tracking_dir):
    """Test status command when no tracking is active"""
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "No active tracking" in result.stdout

def test_status_with_active_tracking(temp_tracking_dir):
    """Test status command with active tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Check status
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "Currently tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout
@

\subsection{Start Command}

The start command begins tracking time with the specified labels. Labels are independent
tags that can be started individually or in groups. If a label is already being tracked,
starting it again just continues the existing tracking (prevents duplicates).

<<start command>>=
@cli.command()
def start(
    labels: List[str] = typer.Argument(..., help="Labels to track (independent tags)"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o", 
                                               help="Offset start time by this many minutes (negative for past)")
):
    """
    Start tracking time with the given labels.
    Labels are independent tags. If a label is already being tracked, it continues.
    Example: nytid track start DD1310 lecture preparation
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    # Calculate start time with offset
    start_time = datetime.datetime.now()
    if offset_minutes is not None:
        start_time += datetime.timedelta(minutes=offset_minutes)
    
    # Load current session
    session = load_active_session()
    
    # Start tracking labels (ignores already-active labels)
    started = session.start_labels(labels, start_time)
    already_tracking = [l for l in labels if l not in started]
    
    # Save session
    save_active_session(session)
    
    # Display what happened
    if started:
        typer.echo(f"Started tracking: {', '.join(sorted(started))}")
    if already_tracking:
        typer.echo(f"Already tracking: {', '.join(sorted(already_tracking))}")
    
    # Show all active labels
    all_active = session.get_active_labels()
    typer.echo(f"Active labels: {', '.join(all_active)}")
    
    if offset_minutes is not None:
        typer.echo(f"Start time offset by {offset_minutes} minutes: {start_time.strftime('%H:%M:%S')}")
@

\subsubsection{Testing Start Command}

<<test start command>>=
def test_start_tracking(temp_tracking_dir):
    """Test starting time tracking"""
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Started tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout

def test_start_duplicate_prevention(temp_tracking_dir):
    """Test that starting same label twice doesn't duplicate"""
    # Start first time
    runner.invoke(cli, ["start", "DD1310"])
    # Start again
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Already tracking: DD1310" in result.stdout
    assert "Started tracking: lecture" in result.stdout

def test_offset_functionality(temp_tracking_dir):
    """Test time offset functionality"""
    result = runner.invoke(cli, [
        "start", "DD1310", "meeting", "--offset", "-10"
    ])
    assert result.exit_code == 0
    assert "Start time offset by -10 minutes" in result.stdout
@

<<stop command>>=
@cli.command()
def stop(
    all_labels: bool = typer.Option(False, "--all", "-a", 
                                  help="Stop tracking for all active labels"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o",
                                               help="Offset stop time by this many minutes (negative for past)")
):
    """
    Stop tracking. By default stops the most recently started labels.
    Use --all to stop all active tracking.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking session", err=True)
        raise typer.Exit(1)
    
    # Calculate end time with offset  
    end_time = datetime.datetime.now()
    if offset_minutes is not None:
        end_time += datetime.timedelta(minutes=offset_minutes)
        # Update the session's label times if we're offsetting
        for i, (label, start_time) in enumerate(session.label_stack):
            session.label_stack[i] = (label, start_time)
    
    # Stop tracking and get completed entries
    if all_labels:
        completed_entries = session.clear_all()
        save_active_session(ActiveSession())  # Clear the session
        typer.echo("Stopped all tracking")
    else:
        completed_entries = session.pop_labels(1)
        save_active_session(session)
        if session.is_active():
            typer.echo(f"Stopped latest label. Still tracking: {get_labels_display(session.get_current_labels())}")
        else:
            typer.echo("Stopped tracking")
    
    # Update end times if offset was provided
    if offset_minutes is not None and completed_entries:
        for entry in completed_entries:
            entry.end_time = end_time
    
    # Save completed entries
    add_completed_entries(completed_entries)
    
    # Display what was completed
    for entry in completed_entries:
        typer.echo(f"Completed: {get_labels_display(entry.labels)} ({format_duration(entry.duration())})")
@

\subsection{Status Command}

The status command shows what is currently being tracked.

<<status command>>=
@cli.command()
def status():
    """
    Show current tracking status.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking")
        return
    
    typer.echo("Currently tracking:")
    current_time = datetime.datetime.now()
    
    for i, (label, start_time) in enumerate(session.label_stack):
        duration = current_time - start_time
        indent = "  " * i
        typer.echo(f"{indent}- {label} (for {format_duration(duration)})")
    
    total_labels = session.get_current_labels()
    typer.echo(f"\nFull label hierarchy: {get_labels_display(total_labels)}")
@

\subsection{Run Command}

The run command tracks time while executing another command.

<<run command>>=
@cli.command()
def run(
    command_args: List[str] = typer.Argument(..., help="Command and arguments to run"),
    labels: List[str] = typer.Option([], "--label", "-l", help="Labels for this tracking session")
):
    """
    Run a command and track the time spent.
    The command should be provided as arguments after the labels.
    """
    if not command_args:
        typer.echo("Error: Command is required", err=True)
        raise typer.Exit(1)
    
    if not labels:
        # Use the command as a label if no labels provided
        labels = [command_args[0]]
    
    start_time = datetime.datetime.now()
    
    # Load current session and add labels
    session = load_active_session()
    session.push_labels(labels, start_time)
    save_active_session(session)
    
    typer.echo(f"Running '{' '.join(command_args)}' and tracking as: {get_labels_display(labels)}")
    
    try:
        # Run the command
        result = subprocess.run(command_args, capture_output=False)
        exit_code = result.returncode
    except KeyboardInterrupt:
        typer.echo("\nCommand interrupted", err=True)
        exit_code = 130
    except FileNotFoundError:
        typer.echo(f"Command not found: {command_args[0]}", err=True)
        exit_code = 127
    
    # Stop tracking and save the completed entry
    end_time = datetime.datetime.now()
    completed_entries = session.pop_labels(len(labels))
    
    # Update end times
    for entry in completed_entries:
        entry.end_time = end_time
    
    # Save state
    save_active_session(session)
    add_completed_entries(completed_entries)
    
    duration = end_time - start_time
    typer.echo(f"Command completed in {format_duration(duration)}")
    
    raise typer.Exit(exit_code)
@

\subsection{Add Command}

The add command allows adding arbitrary time intervals.

<<add command>>=
@cli.command()
def add(
    labels: List[str] = typer.Argument(..., help="Labels for the time entry"),
    duration_minutes: int = typer.Option(..., "--duration", "-d", help="Duration in minutes"),
    start_offset_minutes: int = typer.Option(0, "--start-offset", help="Start time offset in minutes from now (negative for past)"),
    description: str = typer.Option("", "--description", help="Description for this time entry")
):
    """
    Add a time entry for work done when not at the computer.
    Useful for recording time spent in meetings, at whiteboards, etc.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    if duration_minutes <= 0:
        typer.echo("Error: Duration must be positive", err=True)
        raise typer.Exit(1)
    
    # Calculate times
    now = datetime.datetime.now()
    start_time = now + datetime.timedelta(minutes=start_offset_minutes)
    end_time = start_time + datetime.timedelta(minutes=duration_minutes)
    
    # Create and save entry
    entry = TrackingEntry(start_time, end_time, labels, description)
    add_completed_entries([entry])
    
    typer.echo(f"Added entry: {get_labels_display(labels)} ({format_duration(entry.duration())})")
    if description:
        typer.echo(f"Description: {description}")
    typer.echo(f"Time: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
@

\subsection{Stats Command}

The stats command provides statistics about time tracking.

<<stats command>>=
@cli.command()
def stats(
    days: int = typer.Option(7, "--days", help="Number of days to include in stats"),
    weekly_limit: Optional[float] = typer.Option(None, "--weekly-limit", help="Weekly hour limit for warnings (uses config default if not specified)"),
    daily_limit: Optional[float] = typer.Option(None, "--daily-limit", help="Daily hour limit for warnings (uses config default if not specified)")
):
    """
    Show statistics about tracked time.
    
    Uses configured default limits for warnings unless overridden by command options.
    Default limits can be set using:
      nytid config track.weekly_limit -s 40.0
      nytid config track.daily_limit -s 8.0
    """
    # Use config defaults if not specified
    if weekly_limit is None:
        weekly_limit = get_default_weekly_limit()
    if daily_limit is None:
        daily_limit = get_default_daily_limit()
    
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data available")
        return
    
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    
    # Filter entries within the time range
    recent_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not recent_entries:
        typer.echo(f"No tracking data in the last {days} days")
        return
    
    # Calculate totals
    total_time = sum((e.duration() for e in recent_entries), datetime.timedelta())
    total_hours = total_time.total_seconds() / 3600
    
    typer.echo(f"Statistics for the last {days} days:")
    typer.echo(f"Total time: {format_duration(total_time)} ({total_hours:.1f} hours)")
    typer.echo(f"Average per day: {total_hours/days:.1f} hours")
    
    # Check against limits
    if total_hours > (weekly_limit * days / 7):
        typer.echo(f"⚠️  Warning: Exceeding weekly limit of {weekly_limit} hours per week", err=True)
    
    # Daily breakdown
    typer.echo(f"\nDaily breakdown:")
    daily_totals = {}
    for entry in recent_entries:
        date = entry.start_time.date()
        if date not in daily_totals:
            daily_totals[date] = datetime.timedelta()
        daily_totals[date] += entry.duration()
    
    for date in sorted(daily_totals.keys(), reverse=True):
        duration = daily_totals[date]
        hours = duration.total_seconds() / 3600
        warning = " ⚠️" if hours > daily_limit else ""
        typer.echo(f"  {date}: {format_duration(duration)} ({hours:.1f}h){warning}")
    
    # Label breakdown
    typer.echo(f"\nTime by top-level labels:")
    label_totals = {}
    for entry in recent_entries:
        if entry.labels:
            top_label = entry.labels[0]
            if top_label not in label_totals:
                label_totals[top_label] = datetime.timedelta()
            label_totals[top_label] += entry.duration()
    
    for label, duration in sorted(label_totals.items(), key=lambda x: x[1], reverse=True):
        hours = duration.total_seconds() / 3600
        percentage = (duration.total_seconds() / total_time.total_seconds()) * 100
        typer.echo(f"  {label}: {format_duration(duration)} ({hours:.1f}h, {percentage:.1f}%)")
@

\subsection{Export Command}

The export command allows exporting tracking data to various formats.

<<export command>>=
@cli.command()
def export(
    format: str = typer.Option("ics", "--format", "-f", help="Export format (ics, json, csv)"),
    days: int = typer.Option(30, "--days", help="Number of days to export"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output file (stdout if not specified)")
):
    """
    Export tracking data in various formats.
    Supports ICS (calendar), JSON, and CSV formats.
    """
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data to export", err=True)
        return
    
    # Filter by date range
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    filtered_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not filtered_entries:
        typer.echo(f"No tracking data in the last {days} days", err=True)
        return
    
    # Generate export data
    if format.lower() == "ics":
        export_data = export_to_ics(filtered_entries)
    elif format.lower() == "json":
        export_data = export_to_json(filtered_entries)
    elif format.lower() == "csv":
        export_data = export_to_csv(filtered_entries)
    else:
        typer.echo(f"Unsupported format: {format}", err=True)
        raise typer.Exit(1)
    
    # Output to file or stdout
    if output:
        with open(output, 'w') as f:
            f.write(export_data)
        typer.echo(f"Exported {len(filtered_entries)} entries to {output}")
    else:
        print(export_data)

def export_to_ics(entries: List[TrackingEntry]) -> str:
    """Export entries to ICS format"""
    try:
        import ics.icalendar
        import ics.event
    except ImportError:
        typer.echo("ICS export requires the 'ics' package", err=True)
        raise typer.Exit(1)
    
    calendar = ics.icalendar.Calendar()
    
    for entry in entries:
        event = ics.event.Event()
        event.name = f"Work: {get_labels_display(entry.labels)}"
        event.begin = entry.start_time
        event.end = entry.end_time
        
        if entry.description:
            event.description = entry.description
        
        # Add labels as categories
        if entry.labels:
            event.categories = set(entry.labels)
        
        calendar.events.add(event)
    
    return str(calendar)

def export_to_json(entries: List[TrackingEntry]) -> str:
    """Export entries to JSON format"""
    return json.dumps([entry.to_dict() for entry in entries], indent=2)

def export_to_csv(entries: List[TrackingEntry]) -> str:
    """Export entries to CSV format"""
    import io
    import csv
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow(['Start Time', 'End Time', 'Duration (minutes)', 'Labels', 'Description'])
    
    # Write entries
    for entry in entries:
        duration_minutes = entry.duration().total_seconds() / 60
        labels_str = " > ".join(entry.labels)
        writer.writerow([
            entry.start_time.isoformat(),
            entry.end_time.isoformat(),
            f"{duration_minutes:.1f}",
            labels_str,
            entry.description
        ])
    
    return output.getvalue()
@

\section{Testing}

We need comprehensive tests for the track functionality.

<<test clitrack.py>>=
import datetime
import json
import os
import pathlib
import tempfile
import pytest
from typer.testing import CliRunner
from unittest.mock import patch

import sys
sys.path.insert(0, '../src')

from nytid.cli.track import cli, TrackingEntry, ActiveSession
from nytid.cli.track import get_tracking_dir, get_tracking_data_file, get_current_session_file

runner = CliRunner()

@pytest.fixture
def temp_tracking_dir():
    """Create a temporary directory for tracking data during tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_dir = pathlib.Path(tmpdir) / "tracking"
        temp_data_file = temp_dir / "tracking_data.json"
        temp_session_file = temp_dir / "current_session.json"
        
        # Mock the configuration functions to use temporary directory
        with patch('nytid.cli.track.get_tracking_dir', return_value=temp_dir), \
             patch('nytid.cli.track.get_tracking_data_file', return_value=temp_data_file), \
             patch('nytid.cli.track.get_current_session_file', return_value=temp_session_file):
            yield temp_dir

def test_status_no_tracking(temp_tracking_dir):
    """Test status command when no tracking is active"""
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "No active tracking" in result.stdout

def test_start_tracking(temp_tracking_dir):
    """Test starting time tracking"""
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Started tracking: DD1310 > lecture" in result.stdout

def test_status_with_active_tracking(temp_tracking_dir):
    """Test status command with active tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Check status
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "Currently tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout

def test_stop_tracking(temp_tracking_dir):
    """Test stopping time tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop tracking
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 0
    assert "Still tracking: DD1310" in result.stdout

def test_stop_all_tracking(temp_tracking_dir):
    """Test stopping all tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop all tracking
    result = runner.invoke(cli, ["stop", "--all"])
    assert result.exit_code == 0
    assert "Stopped all tracking" in result.stdout

def test_add_manual_entry(temp_tracking_dir):
    """Test adding a manual time entry"""
    result = runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60",
        "--description", "Test grading"
    ])
    assert result.exit_code == 0
    assert "Added entry: DD1310 > grading" in result.stdout
    assert "1h 0m 0s" in result.stdout

def test_stats_no_data(temp_tracking_dir):
    """Test stats command with no data"""
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "No tracking data available" in result.stdout

def test_stats_with_data(temp_tracking_dir):
    """Test stats command with data"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60"
    ])
    
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "Statistics for the last 7 days:" in result.stdout
    assert "DD1310:" in result.stdout

def test_export_json(temp_tracking_dir):
    """Test JSON export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading", 
        "--duration", "30"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "json"])
    assert result.exit_code == 0
    # Should be valid JSON
    data = json.loads(result.stdout)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["labels"] == ["DD1310", "grading"]

def test_export_csv(temp_tracking_dir):
    """Test CSV export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "lecture",
        "--duration", "45"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "csv"])
    assert result.exit_code == 0
    assert "Start Time,End Time,Duration" in result.stdout
    assert "DD1310 > lecture" in result.stdout

def test_run_command(temp_tracking_dir):
    """Test run command with tracking"""
    result = runner.invoke(cli, [
        "run", "--label", "DD1310", "--label", "admin",
        "echo", "test"
    ])
    assert result.exit_code == 0
    assert "Running 'echo test'" in result.stdout
    assert "Command completed" in result.stdout

def test_tracking_entry_duration():
    """Test TrackingEntry duration calculation"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 30, 0)
    entry = TrackingEntry(start, end, ["test"], "test entry")
    
    duration = entry.duration()
    assert duration.total_seconds() == 5400  # 1.5 hours

def test_tracking_entry_serialization():
    """Test TrackingEntry to/from dict conversion"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 0, 0)
    entry = TrackingEntry(start, end, ["DD1310", "lecture"], "test")
    
    data = entry.to_dict()
    assert data["labels"] == ["DD1310", "lecture"]
    assert data["description"] == "test"
    
    # Test round-trip
    entry2 = TrackingEntry.from_dict(data)
    assert entry2.start_time == entry.start_time
    assert entry2.end_time == entry.end_time
    assert entry2.labels == entry.labels
    assert entry2.description == entry.description

def test_active_session_operations():
    """Test ActiveSession label stack operations"""
    session = ActiveSession()
    start_time = datetime.datetime.now()
    
    # Test pushing labels
    session.push_labels(["DD1310", "lecture"], start_time)
    assert session.get_current_labels() == ["DD1310", "lecture"]
    assert session.is_active()
    
    # Test popping one label
    entries = session.pop_labels(1)
    assert len(entries) == 1
    assert entries[0].labels == ["DD1310", "lecture"]
    assert session.get_current_labels() == ["DD1310"]
    
    # Test clearing all
    entries = session.clear_all()
    assert len(entries) == 1
    assert not session.is_active()

def test_offset_functionality(temp_tracking_dir):
    """Test time offset functionality"""
    result = runner.invoke(cli, [
        "start", "DD1310", "meeting", "--offset", "-10"
    ])
    assert result.exit_code == 0
    assert "Start time offset by -10 minutes" in result.stdout
@

\subsection{Stop Command}

The stop command ends tracking for the most recent labels or all labels. By default,
it stops only the most recently added labels (LIFO behavior), but can stop all
active tracking with the [[--all]] flag.

<<stop command>>=
@cli.command()
def stop(
    all_labels: bool = typer.Option(False, "--all", "-a", 
                                  help="Stop tracking for all active labels"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o",
                                               help="Offset stop time by this many minutes (negative for past)")
):
    """
    Stop tracking. By default stops the most recently started labels.
    Use --all to stop all active tracking.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking session", err=True)
        raise typer.Exit(1)
    
    # Calculate end time with offset  
    end_time = datetime.datetime.now()
    if offset_minutes is not None:
        end_time += datetime.timedelta(minutes=offset_minutes)
        # Update the session's label times if we're offsetting
        for i, (label, start_time) in enumerate(session.label_stack):
            session.label_stack[i] = (label, start_time)
    
    # Stop tracking and get completed entries
    if all_labels:
        completed_entries = session.clear_all()
        save_active_session(ActiveSession())  # Clear the session
        typer.echo("Stopped all tracking")
    else:
        completed_entries = session.pop_labels(1)
        save_active_session(session)
        if session.is_active():
            typer.echo(f"Stopped latest label. Still tracking: {get_labels_display(session.get_current_labels())}")
        else:
            typer.echo("Stopped tracking")
    
    # Update end times if offset was provided
    if offset_minutes is not None and completed_entries:
        for entry in completed_entries:
            entry.end_time = end_time
    
    # Save completed entries
    add_completed_entries(completed_entries)
    
    # Display what was completed
    for entry in completed_entries:
        typer.echo(f"Completed: {get_labels_display(entry.labels)} ({format_duration(entry.duration())})")
@

\subsubsection{Testing Stop Command}

<<test stop command>>=
def test_stop_tracking(temp_tracking_dir):
    """Test stopping time tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop tracking
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 0
    assert "Still tracking: DD1310" in result.stdout

def test_stop_all_tracking(temp_tracking_dir):
    """Test stopping all tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop all tracking
    result = runner.invoke(cli, ["stop", "--all"])
    assert result.exit_code == 0
    assert "Stopped all tracking" in result.stdout

def test_stop_error_cases(temp_tracking_dir):
    """Test stop command error conditions"""
    # Try to stop when nothing is running
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 1
    assert "No active tracking session" in result.stdout
@

Now we collect all the subcommands:

<<subcommands>>=
<<status command>>
<<start command>>
<<stop command>>
<<add command>>
<<run command>>
<<stats command>>
<<export command>>
@

\subsection{Add Command}

The add command allows adding arbitrary time intervals for work done when not
at the computer, such as meetings, whiteboard sessions, or other offline activities.

<<add command>>=
@cli.command()
def add(
    labels: List[str] = typer.Argument(..., help="Labels for the time entry"),
    duration_minutes: int = typer.Option(..., "--duration", "-d", help="Duration in minutes"),
    start_offset_minutes: int = typer.Option(0, "--start-offset", help="Start time offset in minutes from now (negative for past)"),
    description: str = typer.Option("", "--description", help="Description for this time entry")
):
    """
    Add a time entry for work done when not at the computer.
    Useful for recording time spent in meetings, at whiteboards, etc.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    if duration_minutes <= 0:
        typer.echo("Error: Duration must be positive", err=True)
        raise typer.Exit(1)
    
    # Calculate times
    now = datetime.datetime.now()
    start_time = now + datetime.timedelta(minutes=start_offset_minutes)
    end_time = start_time + datetime.timedelta(minutes=duration_minutes)
    
    # Create and save entry
    entry = TrackingEntry(start_time, end_time, labels, description)
    add_completed_entries([entry])
    
    typer.echo(f"Added entry: {get_labels_display(labels)} ({format_duration(entry.duration())})")
    if description:
        typer.echo(f"Description: {description}")
    typer.echo(f"Time: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
@

\subsubsection{Testing Add Command}

<<test add command>>=
def test_add_manual_entry(temp_tracking_dir):
    """Test adding a manual time entry"""
    result = runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60",
        "--description", "Test grading"
    ])
    assert result.exit_code == 0
    assert "Added entry: DD1310 > grading" in result.stdout
    assert "1h 0m 0s" in result.stdout

def test_add_error_cases(temp_tracking_dir):
    """Test add command error conditions"""
    # Try to add with invalid duration
    result = runner.invoke(cli, [
        "add", "DD1310", "--duration", "0"
    ])
    assert result.exit_code == 1
    assert "Duration must be positive" in result.stdout
@

Now let me add the remaining commands. I'll create a simplified test section at the end that combines all the test functions:

\section{Comprehensive Testing}

We provide a comprehensive test suite that validates all aspects of the track functionality.

<<test clitrack.py>>=
import datetime
import json
import os
import pathlib
import tempfile
import pytest
from typer.testing import CliRunner
from unittest.mock import patch

import sys
sys.path.insert(0, '../src')

from nytid.cli.track import cli, TrackingEntry, ActiveSession
from nytid.cli.track import get_tracking_dir, get_tracking_data_file, get_current_session_file

runner = CliRunner()

@pytest.fixture
def temp_tracking_dir():
    """Create a temporary directory for tracking data during tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_dir = pathlib.Path(tmpdir) / "tracking"
        temp_data_file = temp_dir / "tracking_data.json"
        temp_session_file = temp_dir / "current_session.json"
        
        # Mock the configuration functions to use temporary directory
        with patch('nytid.cli.track.get_tracking_dir', return_value=temp_dir), \
             patch('nytid.cli.track.get_tracking_data_file', return_value=temp_data_file), \
             patch('nytid.cli.track.get_current_session_file', return_value=temp_session_file):
            yield temp_dir

# Status command tests
<<test status command>>

# Start command tests  
<<test start command>>

# Stop command tests
<<test stop command>>

# Add command tests
<<test add command>>

# Data structure tests
<<test tracking entry>>
<<test active session>>

# Integration tests for other commands
def test_stats_no_data(temp_tracking_dir):
    """Test stats command with no data"""
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "No tracking data available" in result.stdout

def test_stats_with_data(temp_tracking_dir):
    """Test stats command with data"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60"
    ])
    
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "Statistics for the last 7 days:" in result.stdout
    assert "DD1310:" in result.stdout

def test_export_json(temp_tracking_dir):
    """Test JSON export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading", 
        "--duration", "30"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "json"])
    assert result.exit_code == 0
    # Should be valid JSON
    data = json.loads(result.stdout)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["labels"] == ["DD1310", "grading"]

def test_export_csv(temp_tracking_dir):
    """Test CSV export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "lecture",
        "--duration", "45"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "csv"])
    assert result.exit_code == 0
    assert "Start Time,End Time,Duration" in result.stdout
    assert "DD1310 > lecture" in result.stdout

def test_run_command(temp_tracking_dir):
    """Test run command with tracking"""
    result = runner.invoke(cli, [
        "run", "--label", "DD1310", "--label", "admin",
        "echo", "test"
    ])
    assert result.exit_code == 0
    assert "Running 'echo test'" in result.stdout
    assert "Command completed" in result.stdout
@