\chapter{The \texttt{cli.track} module and
         the \texttt{track} subcommands}%
\label{cli.track}

In this chapter we introduce the subcommands found under [[nytid track]],
it's the [[cli.track]] module for time tracking functionality.

\section{Design Overview and Rationale}

The track command allows teachers to track time spent on various course-related activities
such as meetings, grading, preparation time, lectures, etc. The system is designed around
several key principles:

\subsection{Hierarchical Label System}
The core design uses nested labels to represent the natural hierarchy of academic work.
For example, [[DD1310 lecture preparation]] creates a three-level hierarchy where:
\begin{itemize}
\item [[DD1310]] represents the course (top-level category)
\item [[lecture]] represents the activity type (mid-level category)  
\item [[preparation]] represents the specific task (detailed level)
\end{itemize}

This allows for both high-level reporting (total time per course) and detailed analysis 
(time spent on lecture preparation vs. grading).

\subsection{Stack-based Active Session Management}
Active tracking uses a stack-based approach where labels can be added incrementally and
removed in LIFO (Last-In-First-Out) order. This mirrors how academic work naturally occurs:
teachers might start tracking a course, then add a specific activity, then add a detailed
task. When finished with the task, they can stop just that level while continuing to
track the broader activity.

\subsection{Persistent Data Storage}
All tracking data is persisted in JSON format for simplicity and portability. The system
maintains two separate data files:
\begin{itemize}
\item \textbf{Completed entries}: Historical tracking data for analysis and export
\item \textbf{Active session}: Current tracking state that survives application restarts
\end{itemize}

\subsection{Multi-format Export Capability}
The system supports multiple export formats (ICS, JSON, CSV) to integrate with different
tools and workflows that teachers use for time management and reporting.

The main module structure follows nytid's standard patterns:

<<track.py>>=
import datetime
import json
import logging
import os
import pathlib
import sys
import subprocess
import typer
import typerconf as config
from typing_extensions import Annotated
from typing import List, Optional
import time


<<configuration management>>

cli = typer.Typer(name="track",
                  help="Track time spent on course activities")

<<helper functions>>
<<data structures>>
<<tracking state management>>
<<subcommands>>
@

\section{Configuration Management}

The track system uses nytid's configuration system (via typerconf) to store user
preferences and data locations, making it configurable and consistent with other
nytid components.

The track system supports the following configuration options:

\begin{description}
\item[\texttt{track.data\_dir}] Directory where tracking data is stored. 
  Defaults to \texttt{\~{}/.nytid/tracking} if not configured.
\item[\texttt{track.weekly\_limit}] Default weekly hour limit for warnings in statistics. 
  Defaults to 40.0 hours if not configured.
\item[\texttt{track.daily\_limit}] Default daily hour limit for warnings in statistics. 
  Defaults to 8.0 hours if not configured.
\end{description}

To customize the track system, use the standard nytid config commands:

\begin{minted}{bash}
# Set custom data directory
nytid config track.data_dir -s /path/to/custom/tracking/data

# Set weekly hour limit for work-life balance warnings  
nytid config track.weekly_limit -s 35.0

# Set daily hour limit warnings
nytid config track.daily_limit -s 7.5

# View current track configuration
nytid config track.data_dir
nytid config track.weekly_limit  
nytid config track.daily_limit
\end{minted}

The configuration system ensures that track settings are persistent and can be
customized per user or per course context, following nytid's standard patterns.

<<configuration management>>=
# Configuration keys for track system
TRACKING_DIR_CONFIG = "track.data_dir"
DEFAULT_WEEKLY_LIMIT_CONFIG = "track.weekly_limit"
DEFAULT_DAILY_LIMIT_CONFIG = "track.daily_limit"

def get_tracking_dir() -> pathlib.Path:
    """Get the tracking data directory from config, with fallback to default"""
    try:
        tracking_dir = pathlib.Path(config.get(TRACKING_DIR_CONFIG))
    except KeyError:
        # Fallback to default location in user's home directory
        tracking_dir = pathlib.Path.home() / ".nytid" / "tracking"
        # Set the default in config for future use
        config.set(TRACKING_DIR_CONFIG, str(tracking_dir))
    
    return tracking_dir

def get_tracking_data_file() -> pathlib.Path:
    """Get the path to the tracking data file"""
    return get_tracking_dir() / "tracking_data.json"

def get_current_session_file() -> pathlib.Path:
    """Get the path to the current session file"""
    return get_tracking_dir() / "current_session.json"

def get_default_weekly_limit() -> float:
    """Get the default weekly hour limit from config"""
    try:
        return float(config.get(DEFAULT_WEEKLY_LIMIT_CONFIG))
    except (KeyError, ValueError):
        return 40.0  # Default to 40 hours per week

def get_default_daily_limit() -> float:
    """Get the default daily hour limit from config"""
    try:
        return float(config.get(DEFAULT_DAILY_LIMIT_CONFIG))
    except (KeyError, ValueError):
        return 8.0  # Default to 8 hours per day
@

\section{Helper Functions}

We need some utility functions for formatting and display.

<<helper functions>>=
def format_duration(duration: datetime.timedelta) -> str:
    """Format a duration in a human-readable way"""
    total_seconds = int(duration.total_seconds())
    hours, remainder = divmod(total_seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    
    if hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def get_labels_display(labels: List[str]) -> str:
    """Get a display string for labels"""
    return " > ".join(labels) if labels else "No labels"
@

\section{Data Structures and Class Architecture}

The tracking system is built around two main classes that work together to provide
a complete time tracking solution.

\subsection{TrackingEntry Class}

The [[TrackingEntry]] class represents a completed time tracking session. It encapsulates
all the information about a single period of tracked work: when it started and ended,
what labels (categories) it had, and any descriptive notes.

This class serves as the fundamental data unit for historical tracking data. It provides:
\begin{itemize}
\item \textbf{Immutable record}: Once created, entries represent completed work sessions
\item \textbf{Duration calculation}: Automatic computation of time spent
\item \textbf{Serialization support}: JSON conversion for persistent storage
\item \textbf{Label hierarchy}: Maintains the full nested label path for detailed reporting
\end{itemize}

<<tracking entry class>>=
class TrackingEntry:
    """
    Represents a completed time tracking entry.
    
    This class encapsulates all information about a single tracked work session,
    including the time span, hierarchical labels, and optional description.
    Once created, instances are immutable records of completed work.
    """
    
    def __init__(self, start_time: datetime.datetime, end_time: datetime.datetime, 
                 labels: List[str], description: str = ""):
        """
        Initialize a tracking entry.
        
        Args:
            start_time: When the tracked work began
            end_time: When the tracked work ended  
            labels: Hierarchical list of labels (e.g., ['DD1310', 'lecture', 'prep'])
            description: Optional description of the work performed
        """
        self.start_time = start_time
        self.end_time = end_time
        self.labels = labels
        self.description = description
        
    def duration(self) -> datetime.timedelta:
        """
        Calculate the duration of this tracking entry.
        
        Returns:
            The time difference between end_time and start_time
        """
        return self.end_time - self.start_time
        
    def to_dict(self) -> dict:
        """
        Convert to dictionary for JSON serialization.
        
        Returns:
            Dictionary with all entry data in JSON-serializable format
        """
        return {
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat(),
            'labels': self.labels,
            'description': self.description
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'TrackingEntry':
        """
        Create from dictionary (JSON deserialization).
        
        Args:
            data: Dictionary containing serialized entry data
            
        Returns:
            New TrackingEntry instance
        """
        return cls(
            start_time=datetime.datetime.fromisoformat(data['start_time']),
            end_time=datetime.datetime.fromisoformat(data['end_time']),
            labels=data['labels'],
            description=data.get('description', '')
        )
@

\subsubsection{Testing TrackingEntry}

We test the [[TrackingEntry]] class to ensure duration calculation and serialization work correctly.

<<test tracking entry>>=
def test_tracking_entry_duration():
    """Test TrackingEntry duration calculation"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 30, 0)
    entry = TrackingEntry(start, end, ["test"], "test entry")
    
    duration = entry.duration()
    assert duration.total_seconds() == 5400  # 1.5 hours

def test_tracking_entry_serialization():
    """Test TrackingEntry to/from dict conversion"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 0, 0)
    entry = TrackingEntry(start, end, ["DD1310", "lecture"], "test")
    
    data = entry.to_dict()
    assert data["labels"] == ["DD1310", "lecture"]
    assert data["description"] == "test"
    
    # Test round-trip
    entry2 = TrackingEntry.from_dict(data)
    assert entry2.start_time == entry.start_time
    assert entry2.end_time == entry.end_time
    assert entry2.labels == entry.labels
    assert entry2.description == entry.description
@

\subsection{ActiveSession Class}

The [[ActiveSession]] class manages the current tracking state using a stack-based approach.
It maintains a list of (label, start\_time) pairs that represent the currently active
tracking hierarchy.

The stack-based design mirrors how academic work naturally flows:
\begin{itemize}
\item \textbf{Incremental addition}: Labels can be added one at a time as work gets more specific
\item \textbf{LIFO removal}: Most recent labels are stopped first, matching natural work patterns
\item \textbf{Hierarchical context}: Each level maintains its own start time for accurate tracking
\item \textbf{Persistent state}: Session survives application restarts
\end{itemize}

The two classes interact in a producer-consumer pattern:
\begin{itemize}
\item [[ActiveSession]] \textbf{produces} [[TrackingEntry]] objects when labels are stopped
\item [[TrackingEntry]] objects are \textbf{consumed} by the storage and analysis functions
\item Both classes use the same label hierarchy format for consistency
\item Both support JSON serialization using the same patterns
\end{itemize}

<<active session class>>=
class ActiveSession:
    """
    Manages the current tracking state using a stack-based approach.
    
    This class maintains the hierarchy of currently active tracking labels,
    allowing for incremental addition of labels and LIFO removal. Each label
    in the stack has its own start time for accurate time tracking.
    
    The stack design supports natural work patterns where broad categories
    (e.g., 'DD1310') are refined with more specific labels (e.g., 'lecture', 'prep').
    """
    
    def __init__(self):
        """Initialize an empty active session."""
        # Stack of (label, start_time) pairs representing active tracking hierarchy
        self.label_stack: List[tuple] = []
        
    def push_labels(self, labels: List[str], start_time: datetime.datetime):
        """
        Add new labels to the tracking stack.
        
        Args:
            labels: List of labels to add to the stack
            start_time: When tracking of these labels began
        """
        for label in labels:
            self.label_stack.append((label, start_time))
    
    def pop_labels(self, count: int = 1) -> List[TrackingEntry]:
        """
        Remove labels from stack and return completed tracking entries.
        
        This method creates TrackingEntry objects for each removed label,
        using the current time as the end time and the full label hierarchy
        at the time of removal.
        
        Args:
            count: Number of labels to remove from the top of the stack
            
        Returns:
            List of TrackingEntry objects for the completed tracking sessions
        """
        if not self.label_stack:
            return []
            
        end_time = datetime.datetime.now()
        entries = []
        
        for _ in range(min(count, len(self.label_stack))):
            if self.label_stack:
                label, start_time = self.label_stack.pop()
                # Create labels list from current stack + the popped label
                current_labels = [l for l, _ in self.label_stack] + [label]
                entries.append(TrackingEntry(start_time, end_time, current_labels))
                
        return entries
    
    def clear_all(self) -> List[TrackingEntry]:
        """
        Clear all labels and return completed entries.
        
        Returns:
            List of TrackingEntry objects for all active tracking sessions
        """
        return self.pop_labels(len(self.label_stack))
    
    def get_current_labels(self) -> List[str]:
        """
        Get the current active labels as a hierarchical list.
        
        Returns:
            List of labels in hierarchical order (broad to specific)
        """
        return [label for label, _ in self.label_stack]
    
    def is_active(self) -> bool:
        """
        Check if there are any active tracking labels.
        
        Returns:
            True if tracking is active, False otherwise
        """
        return len(self.label_stack) > 0
    
    def to_dict(self) -> dict:
        """
        Convert to dictionary for JSON serialization.
        
        Returns:
            Dictionary with session state in JSON-serializable format
        """
        return {
            'label_stack': [(label, start_time.isoformat()) 
                          for label, start_time in self.label_stack]
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'ActiveSession':
        """
        Create from dictionary (JSON deserialization).
        
        Args:
            data: Dictionary containing serialized session data
            
        Returns:
            New ActiveSession instance with restored state
        """
        session = cls()
        session.label_stack = [
            (label, datetime.datetime.fromisoformat(start_time))
            for label, start_time in data.get('label_stack', [])
        ]
        return session
@

\subsubsection{Testing ActiveSession}

We test the [[ActiveSession]] stack operations to ensure proper LIFO behavior.

<<test active session>>=
def test_active_session_operations():
    """Test ActiveSession label stack operations"""
    session = ActiveSession()
    start_time = datetime.datetime.now()
    
    # Test pushing labels
    session.push_labels(["DD1310", "lecture"], start_time)
    assert session.get_current_labels() == ["DD1310", "lecture"]
    assert session.is_active()
    
    # Test popping one label
    entries = session.pop_labels(1)
    assert len(entries) == 1
    assert entries[0].labels == ["DD1310", "lecture"]
    assert session.get_current_labels() == ["DD1310"]
    
    # Test clearing all
    entries = session.clear_all()
    assert len(entries) == 1
    assert not session.is_active()
@

Now we combine both classes in the data structures chunk:

<<data structures>>=
<<tracking entry class>>
<<active session class>>
@

\section{Tracking State Management}

The state management functions provide the interface between the in-memory data structures
and persistent storage. They handle file I/O, error recovery, and ensure data consistency.

The state management follows these principles:
\begin{itemize}
\item \textbf{Graceful degradation}: Missing or corrupted files don't crash the system
\item \textbf{Automatic recovery}: Invalid data is logged and ignored, allowing continued operation
\item \textbf{Lazy initialization}: Directories and files are created only when needed
\item \textbf{Configuration integration}: File locations respect user configuration
\end{itemize}

\subsection{Directory Management}

We need to ensure the tracking directory exists before writing files.

<<ensure tracking dir>>=
def ensure_tracking_dir():
    """
    Ensure the tracking directory exists.
    
    Creates the tracking data directory if it doesn't exist, including
    any necessary parent directories. Uses the configured location.
    """
    get_tracking_dir().mkdir(parents=True, exist_ok=True)
@

\subsection{Historical Data Management}

Historical tracking data is stored in JSON format for all completed time entries.

<<load tracking data>>=
def load_tracking_data() -> List[TrackingEntry]:
    """
    Load historical tracking data from the persistent storage file.
    
    Returns:
        List of TrackingEntry objects, or empty list if file doesn't exist
        or contains invalid data
    """
    tracking_file = get_tracking_data_file()
    if not tracking_file.exists():
        return []
    
    try:
        with open(tracking_file, 'r') as f:
            data = json.load(f)
            return [TrackingEntry.from_dict(entry) for entry in data]
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading tracking data from {tracking_file}: {e}")
        return []

def save_tracking_data(entries: List[TrackingEntry]):
    """
    Save tracking data to persistent storage.
    
    Args:
        entries: List of TrackingEntry objects to save
    """
    ensure_tracking_dir()
    tracking_file = get_tracking_data_file()
    with open(tracking_file, 'w') as f:
        json.dump([entry.to_dict() for entry in entries], f, indent=2)

def add_completed_entries(new_entries: List[TrackingEntry]):
    """
    Add newly completed entries to the historical tracking data.
    
    This function implements an append-only approach to maintain data integrity.
    It loads existing data, appends new entries, and saves the combined dataset.
    
    Args:
        new_entries: List of TrackingEntry objects to add to historical data
    """
    if not new_entries:
        return
        
    existing_entries = load_tracking_data()
    existing_entries.extend(new_entries)
    save_tracking_data(existing_entries)
@

\subsection{Active Session Management}

The active session maintains the current tracking state and survives application restarts.

<<session management>>=
def load_active_session() -> ActiveSession:
    """
    Load the current active session from persistent storage.
    
    Returns:
        ActiveSession object with restored state, or empty session if
        file doesn't exist or contains invalid data
    """
    session_file = get_current_session_file()
    if not session_file.exists():
        return ActiveSession()
    
    try:
        with open(session_file, 'r') as f:
            data = json.load(f)
            return ActiveSession.from_dict(data)
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        logging.warning(f"Error loading active session from {session_file}: {e}")
        return ActiveSession()

def save_active_session(session: ActiveSession):
    """
    Save the current active session to persistent storage.
    
    Args:
        session: ActiveSession object to save
    """
    ensure_tracking_dir()
    session_file = get_current_session_file()
    with open(session_file, 'w') as f:
        json.dump(session.to_dict(), f, indent=2)
@

Now we combine all state management functions:

<<tracking state management>>=
<<ensure tracking dir>>
<<load tracking data>>
<<session management>>
@

\section{Subcommands}

Now we implement the various subcommands for the track functionality. Each command
is organized with its documentation, implementation, and tests together.

\subsection{Status Command}

The status command shows what is currently being tracked. This is typically the
first command users run to see if any tracking is active.

<<status command>>=
@cli.command()
def status():
    """
    Show current tracking status.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking")
        return
    
    typer.echo("Currently tracking:")
    current_time = datetime.datetime.now()
    
    for i, (label, start_time) in enumerate(session.label_stack):
        duration = current_time - start_time
        indent = "  " * i
        typer.echo(f"{indent}- {label} (for {format_duration(duration)})")
    
    total_labels = session.get_current_labels()
    typer.echo(f"\nFull label hierarchy: {get_labels_display(total_labels)}")
@

\subsubsection{Testing Status Command}

<<test status command>>=
def test_status_no_tracking(temp_tracking_dir):
    """Test status command when no tracking is active"""
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "No active tracking" in result.stdout

def test_status_with_active_tracking(temp_tracking_dir):
    """Test status command with active tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Check status
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "Currently tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout
@

\subsection{Start Command}

The start command begins tracking time with the specified labels. Labels are nested,
meaning that running [[start]] multiple times creates a hierarchy of activities.

<<start command>>=
@cli.command()
def start(
    labels: List[str] = typer.Argument(..., help="Labels to track (can be nested)"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o", 
                                               help="Offset start time by this many minutes (negative for past)")
):
    """
    Start tracking time with the given labels.
    Labels are nested, so 'DD1310 lecture' creates a hierarchy.
    Running start again adds new labels to the current tracking.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    # Calculate start time with offset
    start_time = datetime.datetime.now()
    if offset_minutes is not None:
        start_time += datetime.timedelta(minutes=offset_minutes)
    
    # Load current session
    session = load_active_session()
    
    # Add new labels to the session
    session.push_labels(labels, start_time)
    
    # Save session
    save_active_session(session)
    
    # Display current status
    current_labels = session.get_current_labels()
    typer.echo(f"Started tracking: {get_labels_display(current_labels)}")
    if offset_minutes is not None:
        typer.echo(f"Start time offset by {offset_minutes} minutes: {start_time.strftime('%H:%M:%S')}")
@

\subsubsection{Testing Start Command}

<<test start command>>=
def test_start_tracking(temp_tracking_dir):
    """Test starting time tracking"""
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Started tracking: DD1310 > lecture" in result.stdout

def test_offset_functionality(temp_tracking_dir):
    """Test time offset functionality"""
    result = runner.invoke(cli, [
        "start", "DD1310", "meeting", "--offset", "-10"
    ])
    assert result.exit_code == 0
    assert "Start time offset by -10 minutes" in result.stdout
@

<<stop command>>=
@cli.command()
def stop(
    all_labels: bool = typer.Option(False, "--all", "-a", 
                                  help="Stop tracking for all active labels"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o",
                                               help="Offset stop time by this many minutes (negative for past)")
):
    """
    Stop tracking. By default stops the most recently started labels.
    Use --all to stop all active tracking.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking session", err=True)
        raise typer.Exit(1)
    
    # Calculate end time with offset  
    end_time = datetime.datetime.now()
    if offset_minutes is not None:
        end_time += datetime.timedelta(minutes=offset_minutes)
        # Update the session's label times if we're offsetting
        for i, (label, start_time) in enumerate(session.label_stack):
            session.label_stack[i] = (label, start_time)
    
    # Stop tracking and get completed entries
    if all_labels:
        completed_entries = session.clear_all()
        save_active_session(ActiveSession())  # Clear the session
        typer.echo("Stopped all tracking")
    else:
        completed_entries = session.pop_labels(1)
        save_active_session(session)
        if session.is_active():
            typer.echo(f"Stopped latest label. Still tracking: {get_labels_display(session.get_current_labels())}")
        else:
            typer.echo("Stopped tracking")
    
    # Update end times if offset was provided
    if offset_minutes is not None and completed_entries:
        for entry in completed_entries:
            entry.end_time = end_time
    
    # Save completed entries
    add_completed_entries(completed_entries)
    
    # Display what was completed
    for entry in completed_entries:
        typer.echo(f"Completed: {get_labels_display(entry.labels)} ({format_duration(entry.duration())})")
@

\subsection{Status Command}

The status command shows what is currently being tracked.

<<status command>>=
@cli.command()
def status():
    """
    Show current tracking status.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking")
        return
    
    typer.echo("Currently tracking:")
    current_time = datetime.datetime.now()
    
    for i, (label, start_time) in enumerate(session.label_stack):
        duration = current_time - start_time
        indent = "  " * i
        typer.echo(f"{indent}- {label} (for {format_duration(duration)})")
    
    total_labels = session.get_current_labels()
    typer.echo(f"\nFull label hierarchy: {get_labels_display(total_labels)}")
@

\subsection{Run Command}

The run command tracks time while executing another command.

<<run command>>=
@cli.command()
def run(
    command_args: List[str] = typer.Argument(..., help="Command and arguments to run"),
    labels: List[str] = typer.Option([], "--label", "-l", help="Labels for this tracking session")
):
    """
    Run a command and track the time spent.
    The command should be provided as arguments after the labels.
    """
    if not command_args:
        typer.echo("Error: Command is required", err=True)
        raise typer.Exit(1)
    
    if not labels:
        # Use the command as a label if no labels provided
        labels = [command_args[0]]
    
    start_time = datetime.datetime.now()
    
    # Load current session and add labels
    session = load_active_session()
    session.push_labels(labels, start_time)
    save_active_session(session)
    
    typer.echo(f"Running '{' '.join(command_args)}' and tracking as: {get_labels_display(labels)}")
    
    try:
        # Run the command
        result = subprocess.run(command_args, capture_output=False)
        exit_code = result.returncode
    except KeyboardInterrupt:
        typer.echo("\nCommand interrupted", err=True)
        exit_code = 130
    except FileNotFoundError:
        typer.echo(f"Command not found: {command_args[0]}", err=True)
        exit_code = 127
    
    # Stop tracking and save the completed entry
    end_time = datetime.datetime.now()
    completed_entries = session.pop_labels(len(labels))
    
    # Update end times
    for entry in completed_entries:
        entry.end_time = end_time
    
    # Save state
    save_active_session(session)
    add_completed_entries(completed_entries)
    
    duration = end_time - start_time
    typer.echo(f"Command completed in {format_duration(duration)}")
    
    raise typer.Exit(exit_code)
@

\subsection{Add Command}

The add command allows adding arbitrary time intervals.

<<add command>>=
@cli.command()
def add(
    labels: List[str] = typer.Argument(..., help="Labels for the time entry"),
    duration_minutes: int = typer.Option(..., "--duration", "-d", help="Duration in minutes"),
    start_offset_minutes: int = typer.Option(0, "--start-offset", help="Start time offset in minutes from now (negative for past)"),
    description: str = typer.Option("", "--description", help="Description for this time entry")
):
    """
    Add a time entry for work done when not at the computer.
    Useful for recording time spent in meetings, at whiteboards, etc.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    if duration_minutes <= 0:
        typer.echo("Error: Duration must be positive", err=True)
        raise typer.Exit(1)
    
    # Calculate times
    now = datetime.datetime.now()
    start_time = now + datetime.timedelta(minutes=start_offset_minutes)
    end_time = start_time + datetime.timedelta(minutes=duration_minutes)
    
    # Create and save entry
    entry = TrackingEntry(start_time, end_time, labels, description)
    add_completed_entries([entry])
    
    typer.echo(f"Added entry: {get_labels_display(labels)} ({format_duration(entry.duration())})")
    if description:
        typer.echo(f"Description: {description}")
    typer.echo(f"Time: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
@

\subsection{Stats Command}

The stats command provides statistics about time tracking.

<<stats command>>=
@cli.command()
def stats(
    days: int = typer.Option(7, "--days", help="Number of days to include in stats"),
    weekly_limit: Optional[float] = typer.Option(None, "--weekly-limit", help="Weekly hour limit for warnings (uses config default if not specified)"),
    daily_limit: Optional[float] = typer.Option(None, "--daily-limit", help="Daily hour limit for warnings (uses config default if not specified)")
):
    """
    Show statistics about tracked time.
    
    Uses configured default limits for warnings unless overridden by command options.
    Default limits can be set using:
      nytid config track.weekly_limit -s 40.0
      nytid config track.daily_limit -s 8.0
    """
    # Use config defaults if not specified
    if weekly_limit is None:
        weekly_limit = get_default_weekly_limit()
    if daily_limit is None:
        daily_limit = get_default_daily_limit()
    
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data available")
        return
    
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    
    # Filter entries within the time range
    recent_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not recent_entries:
        typer.echo(f"No tracking data in the last {days} days")
        return
    
    # Calculate totals
    total_time = sum((e.duration() for e in recent_entries), datetime.timedelta())
    total_hours = total_time.total_seconds() / 3600
    
    typer.echo(f"Statistics for the last {days} days:")
    typer.echo(f"Total time: {format_duration(total_time)} ({total_hours:.1f} hours)")
    typer.echo(f"Average per day: {total_hours/days:.1f} hours")
    
    # Check against limits
    if total_hours > (weekly_limit * days / 7):
        typer.echo(f"⚠️  Warning: Exceeding weekly limit of {weekly_limit} hours per week", err=True)
    
    # Daily breakdown
    typer.echo(f"\nDaily breakdown:")
    daily_totals = {}
    for entry in recent_entries:
        date = entry.start_time.date()
        if date not in daily_totals:
            daily_totals[date] = datetime.timedelta()
        daily_totals[date] += entry.duration()
    
    for date in sorted(daily_totals.keys(), reverse=True):
        duration = daily_totals[date]
        hours = duration.total_seconds() / 3600
        warning = " ⚠️" if hours > daily_limit else ""
        typer.echo(f"  {date}: {format_duration(duration)} ({hours:.1f}h){warning}")
    
    # Label breakdown
    typer.echo(f"\nTime by top-level labels:")
    label_totals = {}
    for entry in recent_entries:
        if entry.labels:
            top_label = entry.labels[0]
            if top_label not in label_totals:
                label_totals[top_label] = datetime.timedelta()
            label_totals[top_label] += entry.duration()
    
    for label, duration in sorted(label_totals.items(), key=lambda x: x[1], reverse=True):
        hours = duration.total_seconds() / 3600
        percentage = (duration.total_seconds() / total_time.total_seconds()) * 100
        typer.echo(f"  {label}: {format_duration(duration)} ({hours:.1f}h, {percentage:.1f}%)")
@

\subsection{Export Command}

The export command allows exporting tracking data to various formats.

<<export command>>=
@cli.command()
def export(
    format: str = typer.Option("ics", "--format", "-f", help="Export format (ics, json, csv)"),
    days: int = typer.Option(30, "--days", help="Number of days to export"),
    output: Optional[str] = typer.Option(None, "--output", "-o", help="Output file (stdout if not specified)")
):
    """
    Export tracking data in various formats.
    Supports ICS (calendar), JSON, and CSV formats.
    """
    entries = load_tracking_data()
    
    if not entries:
        typer.echo("No tracking data to export", err=True)
        return
    
    # Filter by date range
    now = datetime.datetime.now()
    cutoff_date = now - datetime.timedelta(days=days)
    filtered_entries = [e for e in entries if e.start_time >= cutoff_date]
    
    if not filtered_entries:
        typer.echo(f"No tracking data in the last {days} days", err=True)
        return
    
    # Generate export data
    if format.lower() == "ics":
        export_data = export_to_ics(filtered_entries)
    elif format.lower() == "json":
        export_data = export_to_json(filtered_entries)
    elif format.lower() == "csv":
        export_data = export_to_csv(filtered_entries)
    else:
        typer.echo(f"Unsupported format: {format}", err=True)
        raise typer.Exit(1)
    
    # Output to file or stdout
    if output:
        with open(output, 'w') as f:
            f.write(export_data)
        typer.echo(f"Exported {len(filtered_entries)} entries to {output}")
    else:
        print(export_data)

def export_to_ics(entries: List[TrackingEntry]) -> str:
    """Export entries to ICS format"""
    try:
        import ics.icalendar
        import ics.event
    except ImportError:
        typer.echo("ICS export requires the 'ics' package", err=True)
        raise typer.Exit(1)
    
    calendar = ics.icalendar.Calendar()
    
    for entry in entries:
        event = ics.event.Event()
        event.name = f"Work: {get_labels_display(entry.labels)}"
        event.begin = entry.start_time
        event.end = entry.end_time
        
        if entry.description:
            event.description = entry.description
        
        # Add labels as categories
        if entry.labels:
            event.categories = set(entry.labels)
        
        calendar.events.add(event)
    
    return str(calendar)

def export_to_json(entries: List[TrackingEntry]) -> str:
    """Export entries to JSON format"""
    return json.dumps([entry.to_dict() for entry in entries], indent=2)

def export_to_csv(entries: List[TrackingEntry]) -> str:
    """Export entries to CSV format"""
    import io
    import csv
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow(['Start Time', 'End Time', 'Duration (minutes)', 'Labels', 'Description'])
    
    # Write entries
    for entry in entries:
        duration_minutes = entry.duration().total_seconds() / 60
        labels_str = " > ".join(entry.labels)
        writer.writerow([
            entry.start_time.isoformat(),
            entry.end_time.isoformat(),
            f"{duration_minutes:.1f}",
            labels_str,
            entry.description
        ])
    
    return output.getvalue()
@

\section{Testing}

We need comprehensive tests for the track functionality.

<<test clitrack.py>>=
import datetime
import json
import os
import pathlib
import tempfile
import pytest
from typer.testing import CliRunner
from unittest.mock import patch

import sys
sys.path.insert(0, '../src')

from nytid.cli.track import cli, TrackingEntry, ActiveSession
from nytid.cli.track import get_tracking_dir, get_tracking_data_file, get_current_session_file

runner = CliRunner()

@pytest.fixture
def temp_tracking_dir():
    """Create a temporary directory for tracking data during tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_dir = pathlib.Path(tmpdir) / "tracking"
        temp_data_file = temp_dir / "tracking_data.json"
        temp_session_file = temp_dir / "current_session.json"
        
        # Mock the configuration functions to use temporary directory
        with patch('nytid.cli.track.get_tracking_dir', return_value=temp_dir), \
             patch('nytid.cli.track.get_tracking_data_file', return_value=temp_data_file), \
             patch('nytid.cli.track.get_current_session_file', return_value=temp_session_file):
            yield temp_dir

def test_status_no_tracking(temp_tracking_dir):
    """Test status command when no tracking is active"""
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "No active tracking" in result.stdout

def test_start_tracking(temp_tracking_dir):
    """Test starting time tracking"""
    result = runner.invoke(cli, ["start", "DD1310", "lecture"])
    assert result.exit_code == 0
    assert "Started tracking: DD1310 > lecture" in result.stdout

def test_status_with_active_tracking(temp_tracking_dir):
    """Test status command with active tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Check status
    result = runner.invoke(cli, ["status"])
    assert result.exit_code == 0
    assert "Currently tracking:" in result.stdout
    assert "DD1310" in result.stdout
    assert "lecture" in result.stdout

def test_stop_tracking(temp_tracking_dir):
    """Test stopping time tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop tracking
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 0
    assert "Still tracking: DD1310" in result.stdout

def test_stop_all_tracking(temp_tracking_dir):
    """Test stopping all tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop all tracking
    result = runner.invoke(cli, ["stop", "--all"])
    assert result.exit_code == 0
    assert "Stopped all tracking" in result.stdout

def test_add_manual_entry(temp_tracking_dir):
    """Test adding a manual time entry"""
    result = runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60",
        "--description", "Test grading"
    ])
    assert result.exit_code == 0
    assert "Added entry: DD1310 > grading" in result.stdout
    assert "1h 0m 0s" in result.stdout

def test_stats_no_data(temp_tracking_dir):
    """Test stats command with no data"""
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "No tracking data available" in result.stdout

def test_stats_with_data(temp_tracking_dir):
    """Test stats command with data"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60"
    ])
    
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "Statistics for the last 7 days:" in result.stdout
    assert "DD1310:" in result.stdout

def test_export_json(temp_tracking_dir):
    """Test JSON export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading", 
        "--duration", "30"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "json"])
    assert result.exit_code == 0
    # Should be valid JSON
    data = json.loads(result.stdout)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["labels"] == ["DD1310", "grading"]

def test_export_csv(temp_tracking_dir):
    """Test CSV export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "lecture",
        "--duration", "45"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "csv"])
    assert result.exit_code == 0
    assert "Start Time,End Time,Duration" in result.stdout
    assert "DD1310 > lecture" in result.stdout

def test_run_command(temp_tracking_dir):
    """Test run command with tracking"""
    result = runner.invoke(cli, [
        "run", "--label", "DD1310", "--label", "admin",
        "echo", "test"
    ])
    assert result.exit_code == 0
    assert "Running 'echo test'" in result.stdout
    assert "Command completed" in result.stdout

def test_tracking_entry_duration():
    """Test TrackingEntry duration calculation"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 30, 0)
    entry = TrackingEntry(start, end, ["test"], "test entry")
    
    duration = entry.duration()
    assert duration.total_seconds() == 5400  # 1.5 hours

def test_tracking_entry_serialization():
    """Test TrackingEntry to/from dict conversion"""
    start = datetime.datetime(2023, 1, 1, 10, 0, 0)
    end = datetime.datetime(2023, 1, 1, 11, 0, 0)
    entry = TrackingEntry(start, end, ["DD1310", "lecture"], "test")
    
    data = entry.to_dict()
    assert data["labels"] == ["DD1310", "lecture"]
    assert data["description"] == "test"
    
    # Test round-trip
    entry2 = TrackingEntry.from_dict(data)
    assert entry2.start_time == entry.start_time
    assert entry2.end_time == entry.end_time
    assert entry2.labels == entry.labels
    assert entry2.description == entry.description

def test_active_session_operations():
    """Test ActiveSession label stack operations"""
    session = ActiveSession()
    start_time = datetime.datetime.now()
    
    # Test pushing labels
    session.push_labels(["DD1310", "lecture"], start_time)
    assert session.get_current_labels() == ["DD1310", "lecture"]
    assert session.is_active()
    
    # Test popping one label
    entries = session.pop_labels(1)
    assert len(entries) == 1
    assert entries[0].labels == ["DD1310", "lecture"]
    assert session.get_current_labels() == ["DD1310"]
    
    # Test clearing all
    entries = session.clear_all()
    assert len(entries) == 1
    assert not session.is_active()

def test_offset_functionality(temp_tracking_dir):
    """Test time offset functionality"""
    result = runner.invoke(cli, [
        "start", "DD1310", "meeting", "--offset", "-10"
    ])
    assert result.exit_code == 0
    assert "Start time offset by -10 minutes" in result.stdout
@

\subsection{Stop Command}

The stop command ends tracking for the most recent labels or all labels. By default,
it stops only the most recently added labels (LIFO behavior), but can stop all
active tracking with the [[--all]] flag.

<<stop command>>=
@cli.command()
def stop(
    all_labels: bool = typer.Option(False, "--all", "-a", 
                                  help="Stop tracking for all active labels"),
    offset_minutes: Optional[int] = typer.Option(None, "--offset", "-o",
                                               help="Offset stop time by this many minutes (negative for past)")
):
    """
    Stop tracking. By default stops the most recently started labels.
    Use --all to stop all active tracking.
    """
    session = load_active_session()
    
    if not session.is_active():
        typer.echo("No active tracking session", err=True)
        raise typer.Exit(1)
    
    # Calculate end time with offset  
    end_time = datetime.datetime.now()
    if offset_minutes is not None:
        end_time += datetime.timedelta(minutes=offset_minutes)
        # Update the session's label times if we're offsetting
        for i, (label, start_time) in enumerate(session.label_stack):
            session.label_stack[i] = (label, start_time)
    
    # Stop tracking and get completed entries
    if all_labels:
        completed_entries = session.clear_all()
        save_active_session(ActiveSession())  # Clear the session
        typer.echo("Stopped all tracking")
    else:
        completed_entries = session.pop_labels(1)
        save_active_session(session)
        if session.is_active():
            typer.echo(f"Stopped latest label. Still tracking: {get_labels_display(session.get_current_labels())}")
        else:
            typer.echo("Stopped tracking")
    
    # Update end times if offset was provided
    if offset_minutes is not None and completed_entries:
        for entry in completed_entries:
            entry.end_time = end_time
    
    # Save completed entries
    add_completed_entries(completed_entries)
    
    # Display what was completed
    for entry in completed_entries:
        typer.echo(f"Completed: {get_labels_display(entry.labels)} ({format_duration(entry.duration())})")
@

\subsubsection{Testing Stop Command}

<<test stop command>>=
def test_stop_tracking(temp_tracking_dir):
    """Test stopping time tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop tracking
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 0
    assert "Still tracking: DD1310" in result.stdout

def test_stop_all_tracking(temp_tracking_dir):
    """Test stopping all tracking"""
    # Start tracking
    runner.invoke(cli, ["start", "DD1310", "lecture"])
    
    # Stop all tracking
    result = runner.invoke(cli, ["stop", "--all"])
    assert result.exit_code == 0
    assert "Stopped all tracking" in result.stdout

def test_stop_error_cases(temp_tracking_dir):
    """Test stop command error conditions"""
    # Try to stop when nothing is running
    result = runner.invoke(cli, ["stop"])
    assert result.exit_code == 1
    assert "No active tracking session" in result.stdout
@

Now we collect all the subcommands:

<<subcommands>>=
<<status command>>
<<start command>>
<<stop command>>
<<add command>>
<<run command>>
<<stats command>>
<<export command>>
@

\subsection{Add Command}

The add command allows adding arbitrary time intervals for work done when not
at the computer, such as meetings, whiteboard sessions, or other offline activities.

<<add command>>=
@cli.command()
def add(
    labels: List[str] = typer.Argument(..., help="Labels for the time entry"),
    duration_minutes: int = typer.Option(..., "--duration", "-d", help="Duration in minutes"),
    start_offset_minutes: int = typer.Option(0, "--start-offset", help="Start time offset in minutes from now (negative for past)"),
    description: str = typer.Option("", "--description", help="Description for this time entry")
):
    """
    Add a time entry for work done when not at the computer.
    Useful for recording time spent in meetings, at whiteboards, etc.
    """
    if not labels:
        typer.echo("Error: At least one label is required", err=True)
        raise typer.Exit(1)
    
    if duration_minutes <= 0:
        typer.echo("Error: Duration must be positive", err=True)
        raise typer.Exit(1)
    
    # Calculate times
    now = datetime.datetime.now()
    start_time = now + datetime.timedelta(minutes=start_offset_minutes)
    end_time = start_time + datetime.timedelta(minutes=duration_minutes)
    
    # Create and save entry
    entry = TrackingEntry(start_time, end_time, labels, description)
    add_completed_entries([entry])
    
    typer.echo(f"Added entry: {get_labels_display(labels)} ({format_duration(entry.duration())})")
    if description:
        typer.echo(f"Description: {description}")
    typer.echo(f"Time: {start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')}")
@

\subsubsection{Testing Add Command}

<<test add command>>=
def test_add_manual_entry(temp_tracking_dir):
    """Test adding a manual time entry"""
    result = runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60",
        "--description", "Test grading"
    ])
    assert result.exit_code == 0
    assert "Added entry: DD1310 > grading" in result.stdout
    assert "1h 0m 0s" in result.stdout

def test_add_error_cases(temp_tracking_dir):
    """Test add command error conditions"""
    # Try to add with invalid duration
    result = runner.invoke(cli, [
        "add", "DD1310", "--duration", "0"
    ])
    assert result.exit_code == 1
    assert "Duration must be positive" in result.stdout
@

Now let me add the remaining commands. I'll create a simplified test section at the end that combines all the test functions:

\section{Comprehensive Testing}

We provide a comprehensive test suite that validates all aspects of the track functionality.

<<test clitrack.py>>=
import datetime
import json
import os
import pathlib
import tempfile
import pytest
from typer.testing import CliRunner
from unittest.mock import patch

import sys
sys.path.insert(0, '../src')

from nytid.cli.track import cli, TrackingEntry, ActiveSession
from nytid.cli.track import get_tracking_dir, get_tracking_data_file, get_current_session_file

runner = CliRunner()

@pytest.fixture
def temp_tracking_dir():
    """Create a temporary directory for tracking data during tests"""
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_dir = pathlib.Path(tmpdir) / "tracking"
        temp_data_file = temp_dir / "tracking_data.json"
        temp_session_file = temp_dir / "current_session.json"
        
        # Mock the configuration functions to use temporary directory
        with patch('nytid.cli.track.get_tracking_dir', return_value=temp_dir), \
             patch('nytid.cli.track.get_tracking_data_file', return_value=temp_data_file), \
             patch('nytid.cli.track.get_current_session_file', return_value=temp_session_file):
            yield temp_dir

# Status command tests
<<test status command>>

# Start command tests  
<<test start command>>

# Stop command tests
<<test stop command>>

# Add command tests
<<test add command>>

# Data structure tests
<<test tracking entry>>
<<test active session>>

# Integration tests for other commands
def test_stats_no_data(temp_tracking_dir):
    """Test stats command with no data"""
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "No tracking data available" in result.stdout

def test_stats_with_data(temp_tracking_dir):
    """Test stats command with data"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading",
        "--duration", "60"
    ])
    
    result = runner.invoke(cli, ["stats"])
    assert result.exit_code == 0
    assert "Statistics for the last 7 days:" in result.stdout
    assert "DD1310:" in result.stdout

def test_export_json(temp_tracking_dir):
    """Test JSON export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "grading", 
        "--duration", "30"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "json"])
    assert result.exit_code == 0
    # Should be valid JSON
    data = json.loads(result.stdout)
    assert isinstance(data, list)
    assert len(data) == 1
    assert data[0]["labels"] == ["DD1310", "grading"]

def test_export_csv(temp_tracking_dir):
    """Test CSV export"""
    # Add some data
    runner.invoke(cli, [
        "add", "DD1310", "lecture",
        "--duration", "45"
    ])
    
    result = runner.invoke(cli, ["export", "--format", "csv"])
    assert result.exit_code == 0
    assert "Start Time,End Time,Duration" in result.stdout
    assert "DD1310 > lecture" in result.stdout

def test_run_command(temp_tracking_dir):
    """Test run command with tracking"""
    result = runner.invoke(cli, [
        "run", "--label", "DD1310", "--label", "admin",
        "echo", "test"
    ])
    assert result.exit_code == 0
    assert "Running 'echo test'" in result.stdout
    assert "Command completed" in result.stdout
@